# Анализ: поля «Старт А»/«Старт Б» при пустом стартовом составе

*Последнее обновление: 2026-02-16*

## Суть проблемы

Если на странице **«Управление составами»** не заполнены стартовые составы (ни у одного игрока не отмечена галочка «Стартовый»), то в **сопоставлении полей** на странице **«Настройки подключения к vMix»** в поля «Старт А…», «Старт Б» всё равно попадают данные из полного состава (Roster). Ожидаемое поведение: при отсутствии стартовых составов эти поля должны быть **пустыми**.

---

## Цепочка данных

1. **Страница «Управление составами»** (`RosterManagementPage.tsx`)
   - Пользователь управляет составом команды: номер, имя, позиция, галочка **«Стартовый»** (`isStarter`).
   - При изменении галочки обновляются:
     - `roster[].isStarter`;
     - `team.startingLineupOrder` — массив индексов в `roster` в порядке стартовой шестёрки + двух либеро (индексы 0–5 — основные, 6–7 — либеро).
   - Если ни одна галочка не стоит: все `isStarter === false`, `startingLineupOrder` при снятии всех галочек становится пустым (или остаётся старым, но без помеченных стартовых).

2. **Страница «Настройки подключения к vMix»** (сопоставление полей)
   - В настройках инпутов vMix поля (например, текстовые поля GT Title) сопоставляются с ключами из справочника данных (`dataMapCatalog`), в том числе:
     - `startingA.player1Number`, `startingA.player1Name`, … `startingA.player6Name`, `startingA.libero1Number`, …
     - `startingB.*` — аналогично для команды B.
   - Значения для отправки в vMix берутся через **`getValueByDataMapKey(match, dataMapKey)`** (`src/shared/getValueByDataMapKey.ts`).

3. **Отправка в vMix** (`useVMix.ts`)
   - Для каждого сопоставленного поля вызывается `getValueByDataMapKey(matchData, mapping.dataMapKey)`; полученная строка уходит в vMix. Логика «пусто vs не пусто» целиком определяется тем, что возвращает `getValueByDataMapKey`.

Итог: поведение полей «Старт А»/«Старт Б» при пустом стартовом составе полностью задаётся реализацией в **`getValueByDataMapKey.ts`** для ключей `startingA.*` и `startingB.*`.

---

## Причина некорректного поведения

Файл: **`src/shared/getValueByDataMapKey.ts`**, блок обработки ключей `starting(A|B).(playerN|liberoN|…)`.

### Текущая логика для позиций игроков (player1–player6)

```ts
const order = startOrder?.[i] ?? roster?.filter((p) => p.isStarter)?.[i];
const player = typeof order === 'number' && roster ? roster[order] : roster?.[i];
```

- `startOrder` = `match[teamKey].startingLineupOrder`
- `i` — индекс позиции в стартовом составе (0–5 для player1–player6).

Когда **ни у кого не отмечен «Стартовый»**:

1. `roster?.filter((p) => p.isStarter)` — пустой массив.
2. `...[i]` даёт `undefined`, значит `order === undefined`.
3. Условие `typeof order === 'number'` ложно.
4. Выполняется ветка `roster?.[i]`: берётся **i-й игрок из полного состава** (roster), без учёта `isStarter`.

В результате в поля «Старт А: номер 1», «Старт А: имя 1», … попадают данные **первых шести игроков из Roster**, а не пустые значения. Аналогично для «Старт Б» при пустом стартовом составе команды B.

Ожидание: при отсутствии стартового состава (нет ни одного игрока с `isStarter` и/или позиция в стартовом составе не определена) для всех `startingA.*` / `startingB.*` должно возвращаться пустое значение (`''`), а не данные из Roster.

---

## Дополнительная особенность реализации

В той же строке:

- `startOrder?.[i]` — это **индекс в roster** (число).
- `roster?.filter((p) => p.isStarter)?.[i]` — это **объект игрока** (i-й стартовый по порядку), а не индекс.

То есть тип `order` получается разный в двух случаях (число vs объект). Далее используется только вариант `typeof order === 'number'` и по индексу берётся `roster[order]`. Если когда-то опираться на «второй» вариант (без `startingLineupOrder`), текущая формула `player = … roster?.[i]` всё равно подставляет i-го по списку roster, а не i-го среди стартовых. Для сценария «нет ни одного стартового» это и даёт описанный баг: подставляется состав Roster вместо пустых полей.

---

## Где именно в коде

| Что | Файл | Участок |
|-----|------|--------|
| Определение значения по ключу типа «Старт А/Б» | `src/shared/getValueByDataMapKey.ts` | Строки 128–148 (блок `startMatch`, ветка `part.startsWith('player')`) |
| Каталог ключей «Старт A/B» | `src/shared/dataMapCatalog.ts` | Ключи `startingA.*`, `startingB.*` (например, строки 212–279) |
| Использование при отправке в vMix | `src/renderer/hooks/useVMix.ts` | Вызовы `getValueByDataMapKey(matchData, mapping.dataMapKey)` (около 627, 642) |
| UI сопоставления полей | `src/renderer/components/VMixInputFieldsPanel.tsx` | Выбор `dataMapKey` для полей инпута |

Корень проблемы — только в `getValueByDataMapKey.ts`: при отсутствии стартового игрока на позиции `i` не должен использоваться запасной вариант `roster?.[i]`.

---

## Рекомендуемое исправление (реализовано)

В `getValueByDataMapKey.ts` для ключей `starting(A|B).playerN…`:

1. **Явно определять игрока стартового состава**:
   - если есть `startingLineupOrder` и задан индекс на позиции `i` — брать `roster[startOrder[i]]`;
   - иначе если есть стартовые по флагу `isStarter` — брать i-го по счёту среди них (например, `roster.filter(p => p.isStarter)[i]`);
   - если на позиции `i` нет ни того ни другого — считать позицию пустой.

2. **Не использовать** `roster?.[i]` как подстановку при пустом/неопределённом стартовом составе. В этом случае для `startingA.*` / `startingB.*` возвращать `''`.

Тогда при отсутствии отмеченных стартовых на странице «Управление составами» все поля «Старт А…» и «Старт Б» в сопоставлении и в vMix будут пустыми, а не заполненными из Roster.

---

## Связь с документацией и тестами

- Описание полей и источников данных: `docs/development/vmix-data-map.md` (раздел 4 «Стартовые составы») — там указано, что источник — стартовый состав (в т.ч. порядок из `startingLineupOrder` или игроки с `isStarter`), а не произвольный roster.
- Юнит-тесты: `tests/unit/shared/getValueByDataMapKey.test.ts` — в текущем виде покрывают случай с заполненным стартовым составом (`baseMatch` с `isStarter: true` и `startingLineupOrder`). Имеет смысл добавить тест: при пустом стартовом составе (все `isStarter: false` и/или пустой `startingLineupOrder`) для ключей `startingA.player1Number`, `startingA.player1Name` и т.п. ожидается `''`, а не значения из первых игроков roster.

После внесения исправления в `getValueByDataMapKey.ts` и добавления теста поведение страницы «Управление составами» и сопоставления полей «Старт А»/«Старт Б» будет соответствовать описанному ожиданию.

---

## Внесённое исправление (2026-02-16)

Исправление внесено в рамках той же сессии.

### Изменения в коде

- **`src/shared/getValueByDataMapKey.ts`** (блок `part.startsWith('player')`):
  - Удалена подстановка `roster?.[i]` при отсутствии стартового игрока на позиции.
  - Игрок стартового состава определяется так:
    - если задан `startingLineupOrder[i]` (индекс в roster) — берётся `roster[rosterIndex]`;
    - иначе берётся i-й по счёту среди игроков с `isStarter === true` (результат `roster.filter(p => p.isStarter)[i]`);
    - если на позиции ни того ни другого нет — возвращается `''`.

### Тест

- **`tests/unit/shared/getValueByDataMapKey.test.ts`**:
  - Добавлен тест «при пустом стартовом составе (нет isStarter) поля Старт А/Б возвращают пустую строку, не данные из Roster»: матч с `isStarter: false` у всех игроков и пустым `startingLineupOrder`; проверяется, что `startingA.player1Number`, `startingA.player1Name`, `startingB.player1Number` и т.п. возвращают `''`.

### Документация

- **CHANGELOG.md** — в разделе «Исправлено» добавлена запись о правке полей «Старт А»/«Старт Б» при пустом стартовом составе.
