# План: автоматические плашки событий (сетбол, матчбол, таймаут) в vMix

*Последнее обновление: 2026-02-16*

В документе приведены общие варианты решения и **зафиксированное направление реализации**: автоматические инпуты с галочками по типам событий (Сетбол А/Б, Матчбол А/Б, Таймаут А/Б), флаг режима «тот же инпут (текст меняется)» / «дополнительный инпут» (`autoEventShowAlongside`), один тип события = один инпут, один набор полей с ключами `event.*`, отметка инпута со счётом (галка или выпадающий список), Clear All Overlays только в vMix, при выключении счёта в приложении — скрытие авто-инпутов, таймаут в приложении (toggle), кнопки «Таймаут А»/«Таймаут Б», ручной показ авто-плашек допускается. При завершении матча авто-плашки явно не скрываем; обратная совместимость по возможности.

## Справочная документация vMix

Актуальная документация: **https://www.vmix.com/help29/** (HTTP WEB API, Shortcut Function Reference, Title, Scripting).

- **Переключение страниц титра по HTTP:** в [Shortcut Function Reference](https://www.vmix.com/help29/ShortcutFunctionReference.html) функция **SelectIndex** для инпута типа Title описана так: *«Title: Starts Page animation according to Value starting from number 1»*. То есть переключение страницы титра по API возможно: `Function=SelectIndex&Input=<инпут>&Value=<номер страницы от 1>`.
- **TitleBeginAnimation** — запуск анимации по имени (параметры Value = Animation, Input); для перехода на конкретную страницу по номеру используется именно **SelectIndex**.
- **Scripting** (редакции 4K и Pro): скрипты на VB.NET или Web Scripting, запускаются через Shortcut (ScriptStart). Могут вызывать те же функции, что и API, и выполняться по таймеру или по событию.

## Цель

Реализовать сценарий, при котором при наступлении событий **сетбол**, **матчбол** или **таймаут** в vMix автоматически показывается соответствующая плашка и скрывается, когда событие заканчивается. Важное условие: эти плашки должны быть видны **только когда в эфире отображается плашка со счётом** — то есть привязаны к видимости инпута со счётом.

## Текущее состояние приложения

### Что уже есть

- **Настройка vMix** (страница «Настройки vMix»): пользователь создаёт несколько инпутов, сопоставляет поля с данными приложения (dataMapKey / customValue). Каждый инпут может быть привязан к одному из оверлеев 1–8.
- **Управление плашками** (страница «Управление матчем», блок «Управление плашками vMix»): кнопки включения/выключения отображения каждого настроенного инпута в его оверлее. Данные в инпутах обновляются из приложения автоматически (через `useVMix.updateMatchData` → `updateDynamicInputs`).
- **События в домене**: приложение уже вычисляет сетбол и матчбол по правилам варианта (зал/пляж/снежный) в `useMatch` и в `volleyballRules`:
  - `isSetballNow`, `setballTeam`
  - `isMatchballNow`, `matchballTeam`
- Таймаут в текущей реализации — отдельная сущность (состояние матча/партии), которую при необходимости можно учитывать аналогично.
- **Опрос состояния оверлеев:** приложение запрашивает состояние оверлеев vMix (GET API → XML) с интервалом **2 секунды** (`OVERLAY_POLL_INTERVAL` в `useVMix.ts`). Кнопки «Управление плашками vMix» и внутренняя логика (какой инпут активен в оверлее) обновляются по результатам этого опроса.

В большинстве сценариев ручного включения/выключения плашек достаточно. Не хватает именно **автоматического появления/исчезновения** плашки при наступлении/окончании события и **жёсткой привязки к видимости плашки со счётом**.

### Важно: задержка из‑за опроса раз в 2 секунды

Если мы будем показывать/скрывать событийную плашку в зависимости от того, активен ли оверлей со счётом, то **источником истины** о состоянии оверлея со счётом у нас будет именно этот опрос. В результате:

- Пользователь **выключил** плашку со счётом в vMix (оверлей 1 выключен). Наше приложение узнает об этом **не более чем через 2 секунды**. До следующего опроса мы считаем, что оверлей со счётом ещё активен, и при активном событии (сетбол/матчбол/таймаут) **событийная плашка может продолжать висеть в эфире до обновления статуса**.
- Итог: в худшем случае событийная плашка остаётся на экране до **~2 секунд** после того, как пользователь убрал счёт.

Это нужно учитывать при выборе варианта и при реализации. Возможные меры:
- **Уменьшить интервал опроса** (например, до 1 с или 500 мс) — быстрее реакция, выше нагрузка на vMix API и сеть.
- **Перед каждым показом событийной плашки** выполнять одноразовый запрос состояния оверлеев и не вызывать show, если оверлей со счётом уже неактивен (снижает вероятность «висящей» плашки при только что выключенном счёте, но не устраняет задержку после выключения).
- **Гибрид со скриптом в vMix** (см. вариант 4): скрипт внутри vMix по короткому таймеру проверяет оверлей со счётом и при необходимости сразу скрывает событийный оверлей, не дожидаясь нашего опроса.

## Требования к решению

1. **Автоматика**: при наступлении события (сетбол/матчбол/таймаут) плашка появляется в эфире без нажатия кнопки; при окончании события — скрывается.
2. **Зависимость от счёта**: если плашка со счётом не показывается (пользователь её выключил), то и событийные плашки показываться не должны.
3. **Данные**: содержимое событийных плашек (текст «Сетбол»/«Матчбол», при необходимости команда и т.д.) должно браться из приложения и обновляться так же, как у остальных инпутов (dataMapKey / обновление полей по матчу).

## Варианты решения

Ниже рассмотрены четыре подхода. Выбор зависит от предпочтений по количеству инпутов/оверлеев в vMix, от готовности настраивать титр со страницами или слоями видимости и от того, приемлема ли дополнительная настройка скриптов в vMix (вариант 4).

---

### Вариант 1: Отдельный инпут в отдельном оверлее (рекомендуемый)

**Идея:** Для событий (сетбол/матчбол/таймаут) завести **отдельный vMix-инпут** в **отдельном оверлее** (например, оверлей 2, если счёт в оверлее 1). Приложение автоматически вызывает `OverlayInput2In` / `OverlayInput2Out` при наступлении/окончании события и **только если** оверлей со счётом (например, 1) в данный момент активен.

**Плюсы:**

- Минимальные изменения в конфигурации vMix: один новый инпут и один оверлей, привычная схема «инпут — оверлей».
- Полный контроль с нашей стороны: показ/скрытие через уже используемый API (`OverlayInput[N]In` / `OverlayInput[N]Out`).
- Не зависит от поддержки «страниц» в GT Title и от наличия HTTP API для переключения страниц.
- Можно иметь один инпут «События» с полями типа «Тип» (Сетбол/Матчбол/Таймаут) и «Команда» (A/B), либо три отдельных инпута — по вкусу пользователя.

**Минусы:**

- Занимается ещё один оверлей (2 из 8).
- Нужно в приложении явно хранить/настраивать «инпут со счётом» (или оверлей со счётом), чтобы проверять: «показывать событийную плашку только если оверлей со счётом активен».
- **Задержка реакции на выключение счёта:** состояние оверлеев мы узнаём из опроса раз в 2 секунды. Если пользователь выключил плашку со счётом, событийная плашка может оставаться в эфире до следующего опроса (до ~2 с). См. раздел выше про меры (уменьшение интервала, одноразовый запрос перед show, гибрид со скриптом vMix).

**Реализация (кратко):**

1. В настройках vMix: новый инпут (например, `eventOverlay`), привязка к оверлею 2 (или другому свободному), настройка полей с dataMapKey для текста события и при необходимости команды.
2. В `dataMapCatalog` и `getValueByDataMapKey`: добавить ключи, например `event.setballLabel`, `event.matchballLabel`, `event.timeoutLabel`, `event.team` (A/B) и т.д., вычисляемые из `isSetballNow`, `setballTeam`, `isMatchballNow`, `matchballTeam` и состояния таймаута.
3. В `useVMix` (или отдельном хуке): по изменению состояния матча (сетбол/матчбол/таймаут) и по состоянию оверлея со счётом:
   - если событие активно и оверлей со счётом активен → `showOverlay(eventInputKey)` (и обновить поля инпута);
   - если событие неактивно или оверлей со счётом неактивен → `hideOverlay(eventInputKey)`.
4. Источник «какой оверлей считать оверлеем со счётом»: либо из конфига (например, первый инпут с типом «счёт» или явная настройка «оверлей счёта»), либо по соглашению (например, оверлей 1).

**Практики спортивных трансляций:** Типичный подход в vMix — отдельные оверлеи под разные типы графики (счёт, реклама, события). Автоматизация показа по порогам (например, «бонус» в баскетболе при 6 фолах) в обсуждениях vMix часто делается скриптами или внешним софтом, который дергает API показа/скрытия оверлея — наш вариант с отдельным оверлеем и логикой в приложении этому соответствует.

---

### Вариант 2: Страницы (Pages) в одном титре vMix

**Идея:** Один GT Title инпут с **несколькими страницами**: например, «Счёт», «Сетбол», «Матчбол», «Таймаут». В оверлее показывается всегда этот один инпут; приложение переключает **текущую страницу** титра в зависимости от события (счёт / сетбол / матчбол / таймаут). Условие «показывать событийную плашку только если показывается счёт» трактуется так: оверлей один — когда он выключен, не показывается ни счёт, ни события; когда включён — отображается та страница, которую мы выбрали (счёт или событие).

**Плюсы:**

- Один инпут, один оверлей — экономия слоёв.
- Один титр может содержать единый дизайн для счёта и для событий (общая подложка, шрифты).

**Минусы:**

- Логика «сейчас показываем счёт, при событии — временно страницу события» реализуется в приложении как смена страницы титра; при этом данные полей для каждой страницы должны быть актуальны (обновление полей по матчу для текущей страницы).
- Та же задержка до 2 секунд при выключении пользователем оверлея со счётом: мы узнаем об этом при следующем опросе; до этого на экране может оставаться страница события (или весь титр, если пользователь выключил оверлей).

**Реализация (по документации vMix help29):**

1. В настройках: один инпут типа GT Title с несколькими страницами (например, 1 = счёт, 2 = сетбол, 3 = матчбол, 4 = таймаут); сопоставление полей для каждой страницы (или общих полей).
2. В приложении: при смене состояния события вызывать HTTP API **SelectIndex**: `Function=SelectIndex&Input=<инпут титра>&Value=<номер страницы от 1>`. В [Shortcut Function Reference](https://www.vmix.com/help29/ShortcutFunctionReference.html) для Title указано: *«Starts Page animation according to Value starting from number 1»*.
3. Условие «показывать только при включённом счёте»: оверлей один — его вкл/выкл пользователь делает вручную; мы только меняем страницу внутри этого оверлея. Задержка реакции на выключение оверлея — как в варианте 1 (опрос раз в 2 с).

**Практики:** На форумах vMix для автоматического перехода на страницу титра также упоминают TitleBeginAnimation; для перехода на страницу по номеру через HTTP подходит SelectIndex.

---

### Вариант 3: Один инпут со счётом — слои видимости (SetTextVisibleOn/Off)

**Идея:** Не добавлять новый оверлей и не переключать страницы. В **том же инпуте**, где отображается счёт, добавить в шаблоне GT Title отдельные текстовые элементы (слой «Сетбол», слой «Матчбол», слой «Таймаут»). Приложение обновляет текст этих полей (SetText) и управляет их видимостью через **SetTextVisibleOn** / **SetTextVisibleOff** в зависимости от события. Плашка со счётом и событийная информация живут в одном инпуте; видимость события = видимость слоя.

**Плюсы:**

- Один инпут, один оверлей; не нужен API переключения страниц.
- Уже используемые в проекте команды: SetText, SetTextVisibleOn/Off (см. справочник vMix API и поля `visibility.pointA`/`visibility.pointB`).
- Привязка к счёту тривиальна: если пользователь выключил оверлей со счётом, весь инпут скрыт — и счёт, и события.

**Минусы:**

- Шаблон титра в vMix должен быть изначально спроектирован под такой сценарий: отдельные поля под «Сетбол», «Матчбол», «Таймаут» и, при необходимости, под команду. Не все готовые шаблоны это допускают.
- Возможные наложения: слой события и слой счёта на одном экране — нужно продумать расположение (например, баннер события сверху/снизу, счёт по центру).
- Три типа событий × видимость и текст — больше полей в настройках сопоставления (dataMapKey для текста и отдельно логика видимости по типу события).

**Реализация (кратко):**

1. В `dataMapCatalog` и `getValueByDataMapKey`: ключи для текста и флагов событий (например, `event.setballText`, `event.matchballText`, `event.timeoutText`, плюс флаги видимости для каждого типа).
2. В настройках инпута со счётом: сопоставить поля титра с этими ключами; для полей-слоёв событий использовать тип «visibility» или комбинацию text + отдельная логика видимости в коде.
3. В `updateSingleDynamicInput` (или аналоге): при обновлении инпута со счётом вычислять текущее событие и вызывать SetTextVisibleOn/Off для соответствующих полей. Условие «показывать только при включённом счёте» выполняется автоматически (оверлей один).

**Практики:** Управление видимостью элементов по данным (XML/логика) в vMix применяется, в том числе для индикаторов владения мячом и т.п.; наш случай с сетболом/матчболом аналогичен.

---

### Вариант 4: Скрипты в vMix (4K / Pro)

**Идея:** Часть логики перенести в **скрипт vMix** (VB.NET или Web Scripting). Скрипт по таймеру (например, каждые 0,5–1 с) запрашивает состояние vMix (оверлей со счётом) и, если оверлей со счётом выключен, сразу вызывает скрытие событийного оверлея. Показ событийной плашки при наступлении события по‑прежнему инициирует **наше приложение** через HTTP API (OverlayInput2In и обновление полей). То есть скрипт решает только проблему задержки: «пользователь выключил счёт — событийная плашка должна исчезнуть немедленно», не дожидаясь нашего опроса раз в 2 секунды.

**Плюсы:**

- Уменьшение или устранение задержки до 2 секунд при выключении счёта: скрипт может опрашивать состояние чаще или реагировать на события внутри vMix.
- Логика «событийная плашка только при включённом счёте» выполняется на стороне vMix и не зависит от частоты наших запросов.

**Минусы:**

- **Дополнительная настройка для пользователя:** помимо нашего приложения нужно создать и включить скрипт в vMix (Settings → Scripting), привязать его к Shortcut при необходимости, настроить таймер/триггер. Риск ошибок при копировании или обновлении скрипта.
- **Доступность:** скрипты доступны только в редакциях **4K и Pro** ([Scripting and Automation](https://www.vmix.com/help29/ScriptingandAutomation.html)). Пользователи других редакций не смогут использовать этот вариант.
- Два места поддержки логики: наше приложение (показ/скрытие по событию, данные полей) и vMix (принудительное скрытие при выключении счёта). При изменении номеров оверлеев или конфигурации нужно синхронизировать и скрипт.
- Не заменяет полностью реализацию в приложении: источник истины о сетболе/матчболе/таймауте — наше приложение; скрипт лишь «подчищает» видимость событийного оверлея при выключении счёта.

**Реализация (кратко):**

1. В приложении — как в варианте 1: отдельный инпут событий в отдельном оверлее, показ/скрытие по изменению события и по состоянию оверлея со счётом (по результатам опроса раз в 2 с).
2. В vMix: скрипт (например, по таймеру 500 мс), который запрашивает состояние оверлеев (GET API или через внутренний API скрипта), проверяет, активен ли оверлей со счётом; если нет — отправляет команду скрытия событийного оверлея (OverlayInput2Out или соответствующий номер).
3. Документация для пользователя: пошаговая настройка скрипта, номера оверлеев, предупреждение про 4K/Pro.

**Вывод:** Вариант можно добавить в сравнение как **опциональное дополнение** к варианту 1 для уменьшения задержки, а не как замену приложения. Из‑за необходимости настраивать скрипт в vMix и ограничения по редакциям он менее удобен, чем чистая реализация в приложении с уменьшенным интервалом опроса или одноразовой проверкой перед показом.

---

## Сравнение вариантов

| Критерий                         | Вариант 1 (отдельный оверлей) | Вариант 2 (страницы титра) | Вариант 3 (слои видимости) | Вариант 4 (скрипты vMix) |
|----------------------------------|-------------------------------|----------------------------|----------------------------|---------------------------|
| Использование оверлеев           | +1 оверлей                    | без изменений              | без изменений              | как вариант 1 (+1 оверлей) |
| Сложность шаблона в vMix         | Отдельный титр под события   | Один титр, несколько страниц | Один титр, несколько полей-слоёв | как вариант 1 |
| Зависимость от HTTP API vMix     | Только Overlay In/Out         | SelectIndex для страницы  | Только SetText + Visible On/Off | API + скрипт в vMix |
| Привязка к видимости счёта       | В коде по состоянию оверлея 1 | Один оверлей = счёт и события | Один инпут = автоматически | скрипт может снять задержку 2 с |
| Задержка при выключении счёта    | до ~2 с (опрос раз в 2 с)     | до ~2 с                    | нет (один инпут)           | меньше (если скрипт опрашивает чаще) |
| Доп. настройка для пользователя  | нет                           | нет                        | нет                        | да: скрипт в vMix (4K/Pro) |
| Гибкость (разные дизайны счёт/события) | Высокая                       | Средняя (один титр)       | Средняя (один титр)       | как вариант 1 |

## Рекомендация

- **Предпочтительный вариант для первой реализации — Вариант 1** (отдельный инпут в отдельном оверлее): он опирается только на уже используемый API, переключение страниц титра не требуется, и он хорошо согласуется с практикой «отдельный оверлей под тип графики» в спортивных трансляциях. Зависимость «показывать событийную плашку только при включённом счёте» реализуется проверкой состояния оверлея со счётом (по результатам опроса) перед вызовом show/hide для событийного инпута. **Задержка до ~2 секунд** при выключении пользователем плашки со счётом учитывается; при необходимости её можно уменьшить уменьшением интервала опроса или одноразовой проверкой перед показом событийной плашки.
- **Вариант 2** реализуем по официальной документации vMix help29: переключение страницы титра через **SelectIndex** (`Value` = номер страницы от 1). Подходит, если нужен один оверлей и один титр с несколькими страницами (счёт, сетбол, матчбол, таймаут).
- **Вариант 3** имеет смысл, если пользователь хочет один инпут и один оверлей и готов настроить титр с отдельными слоями под события; привязка к счёту автоматическая, задержки при выключении счёта нет.
- **Вариант 4** (скрипты vMix) — опциональное **дополнение** к варианту 1 для снижения задержки при выключении счёта: скрипт в vMix может чаще проверять оверлей со счётом и сразу скрывать событийный оверлей. Требует от пользователя настройки скрипта в vMix (4K/Pro), поэтому менее удобен; приоритет — реализация в приложении (интервал опроса или проверка перед show).

## Уточнённое направление реализации (авто-инпуты по командам + Clear All Overlays)

Ниже — развитие плана в сторону конкретной модели: автоматические инпуты с привязкой к команде (А/Б), явное выделение инпута со счётом и использование триггера vMix **Clear All Overlays**.

### Роль Clear All Overlays (принято)

- **Clear All Overlays настраивается и вызывается только в vMix.** Приложение к этому триггеру отношения не имеет.
- **Дополнительно:** при нажатии пользователем в **нашем приложении** кнопки, которая **выключает счёт** (скрывает плашку со счётом), приложение должно также **скрыть все автоматические инпуты** (вызвать hideOverlay для каждого авто-инпута). Тогда при выключении счёта из приложения авто-плашки исчезают сразу, без ожидания опроса и без участия vMix Shortcut.

---

### Принятые решения (ответы на уточняющие вопросы)

| Вопрос | Решение |
|--------|---------|
| Clear All Overlays | Только в vMix. В приложении при нажатии «выключить счёт» — дополнительно скрываем все авто-инпуты. |
| Привязка авто-инпута к событиям | Галочки по типам событий: «Сетбол А», «Матчбол А», «Таймаут А», «Сетбол Б», «Матчбол Б», «Таймаут Б». Варианты сопоставления полей — см. ниже. |
| Инпут со счётом | Варианты: галка на инпуте или отдельное поле «Выберите инпут для счёта» с выпадающим списком. См. ниже. |
| Таймаут | Хранить состояние таймаута в приложении. Добавить две кнопки «Таймаут А» и «Таймаут Б». Расположение на странице «Управление матчем» — см. ниже. |
| Авто-инпуты в блоке «Управление плашками vMix» | Допускать **ручной показ**: авто-инпуты отображаются в списке с пометкой «автоматический». |
| Приоритет событий | Показывать **один тип по приоритету** (при нескольких возможных событиях — одно выбранное). |

---

### Уточнённые требования к реализации

1. **Автоматический инпут: привязка к типам событий**  
   - У инпута можно включить режим «автоматический для событий» и проставить **галочки** для части или всех типов: **Сетбол А**, **Матчбол А**, **Таймаут А**, **Сетбол Б**, **Матчбол Б**, **Таймаут Б**.  
   - Инпут показывается автоматически только при наступлении того типа события, для которого стоит галочка (и при активном оверлее со счётом).  
   - Один и тот же инпут может обслуживать несколько типов (например, все три для команды А — тогда один титр на три события с подстановкой текста и цвета).

2. **Инпут со счётом**  
   - Один из инпутов считается инпутом со счётом (способ выбора — см. варианты ниже). По нему определяется оверлей «плашка со счётом»: авто-плашки показываются только если этот оверлей активен.  
   - При нажатии в приложении кнопки «выключить счёт» (скрыть этот инпут) приложение также скрывает все автоматические инпуты.

3. **Показ/скрытие по событиям**  
   - Шесть типов событий: Сетбол А/Б, Матчбол А/Б, Таймаут А/Б. При наступлении события показываем инпут, у которого стоит галочка на этот тип; при окончании — скрываем.  
   - Если одновременно возможно несколько событий — показываем **один по приоритету** (порядок приоритета уточняется отдельно).

4. **Условие «счёт выведен»**  
   - Не показывать авто-инпуты, если оверлей со счётом неактивен. При обнаружении на опросе, что счёт выключен, — скрывать все наши авто-оверлеи.

---

### Сопоставление полей автособытия (принятая схема)

- **Триггеры** (по которым инпут включается автоматически) задаются в настройках инпута **галочками** по шести типам событий (Сетбол А/Б, Матчбол А/Б, Таймаут А/Б). Это уже зафиксировано выше.
- **Поля инпута** сопоставляются **обычным образом** — как у любого другого инпута (выбор поля титра и привязка к данным приложения через карту данных).
- В **карту данных** (dataMapCatalog и getValueByDataMapKey) вводится **одно новое поле** для текста автособытия:
  - **Название в карте данных:** «Автособытие» (в интерфейсе выбора данных) или «Текст автособытия» (более развёрнутый вариант — при необходимости можно использовать его). В коде — ключ, например `event.autoLabel` или `event.label`.
  - **Значение:** в этом поле подставляется текст **«Сетбол»**, **«Матчбол»** или **«Таймаут»** в зависимости от того, **для какого типа события сейчас показывается данный инпут** (см. ниже про контекст).
  - Пользователь сопоставляет это поле с **любым текстовым полем** титра в vMix — так же, как и остальные поля (один раз в настройках инпута).

**Важно: контекст при разрешении «Автособытия»**

Если сетбол/матчбол отображаются в одном инпуте, а таймаут — в другом (дополнительный инпут), то при смене события на таймаут оба инпута остаются на экране, но текст «Автособытие» должен быть разным: в инпуте сетбола — «Сетбол», в инпуте таймаута — «Таймаут». Если бы значение бралось из одного «текущего события» глобально, оба инпута получили бы «Таймаут», и надпись сетбол/матчбол пропала бы.

**Решение:** значение поля «Автособытие» разрешать **в контексте того события, для которого этот конкретный инпут сейчас показывается**. При обновлении полей авто-инпута приложение знает, какой тип события привёл к показу именно этого инпута (по галочкам и текущей логике показа). Эту информацию передаём в разрешение карты данных:

- При обновлении инпута, показанного для **сетбола А**, передаём контекст «setballA» → для ключа «Автособытие» возвращаем **«Сетбол»**.
- При обновлении инпута, показанного для **таймаута А**, передаём контекст «timeoutA» → для «Автособытие» возвращаем **«Таймаут»**.

То есть вызов разрешения данных для авто-инпута имеет вид: не просто `getValueByDataMapKey(match, key)`, а с опциональным контекстом, например `getValueByDataMapKey(match, key, { eventType: 'setballA' })`. Для ключа «Автособытие» возвращается текст, соответствующий переданному `eventType` (setballA → «Сетбол», matchballA → «Матчбол», timeoutA → «Таймаут» и т.д.). Остальные ключи карты данных по желанию тоже могут учитывать контекст (цвет/логотип команды по событию). В результате у каждого авто-инпута в поле «Автособытие» подставляется только тот текст, который относится к его текущему событию, а не к «глобально текущему» событию.

Остальные поля инпута (цвет команды, логотип, название команды и т.д.) при необходимости сопоставляются с уже существующими или дополнительными ключами карты данных; при использовании контекста по типу события они тоже могут зависеть от переданного `eventType`. Минимально необходимый вариант для первой версии — одно поле «Автособытие» с контекстным разрешением по типу события для каждого обновляемого инпута.

**Сложность подхода и альтернативы**

- **Оценка сложности контекстного варианта:**  
  - **getValueByDataMapKey:** добавить опциональный третий параметр (объект контекста, например `options?: { eventType?: string }`). Для ключа «Автособытие» при наличии `options.eventType` возвращать текст по типу события (простая маппинг-таблица или switch по шести значениям). Остальные ключи контекст не используют. Объём изменений в shared — небольшой.  
  - **Цепочка вызовов:** в useVMix при обновлении авто-инпута уже известен тип события, для которого этот инпут показывается (логика «какие инпуты и для каких событий показывать» там же). Нужно передать этот тип в вызов, который собирает поля для инпута (например, в `updateSingleDynamicInput` или в цикл по полям), и оттуда — в `getValueByDataMapKey`. То есть проброс одного аргумента в один слой. Усложнение кода — умеренное, точечное.

- **Альтернатива 1: Разрешать «Автособытие» в месте вызова (без изменения getValueByDataMapKey).**  
  В useVMix при сборке полей для авто-инпута: если поле сопоставлено с ключом `event.autoLabel`, не вызывать `getValueByDataMapKey`, а подставить текст по известному `eventType` (локальная таблица setballA → «Сетбол» и т.д.).  
  **Плюс:** сигнатура `getValueByDataMapKey` не меняется; shared остаётся без контекста.  
  **Минус:** знание о том, что ключ «Автособытие» зависит от типа события, дублируется (карта данных + useVMix); любые будущие контекстные ключи (цвет/логотип по событию) потребуют ещё специальных случаев в useVMix.

- **Альтернатива 2: Шесть отдельных ключей в карте данных.**  
  Ввести ключи вида `event.autoLabel.setballA`, `event.autoLabel.timeoutA` и т.д., каждый возвращает один текст. В конфиге инпута поле по-прежнему одно, но при обновлении вызывать `getValueByDataMapKey(match, 'event.autoLabel.' + eventType)`.  
  **Минус:** в конфиге нельзя один раз указать «это поле — Автособытие», потому что конкретный ключ зависит от события; пришлось бы либо хранить в конфиге «базовый» ключ и подставлять суффикс в рантайме (по сути тот же контекст), либо дублировать шесть ключей в каталоге и усложнять выбор в UI. Не упрощает реализацию.

- **Оптимизация:** контекст — один небольшой объект или строка `eventType`, передаётся только при обновлении авто-инпутов; клонирование match не требуется. Дополнительные расходы по памяти и производительности пренебрежимы.

**Рекомендация:** контекстный параметр в `getValueByDataMapKey` даёт одно место для всех контекстно зависимых ключей и упрощает добавление новых (например, цвет/логотип по событию). Если хочется не трогать shared, допустима альтернатива 1 (специальная обработка `event.autoLabel` в useVMix) как компромисс при единственном таком ключе.

---

### Режим автоматического инпута: «тот же инпут (текст меняется)» vs «дополнительный инпут»

При сетболе или матчболе команда может запросить таймаут — таймаут нужно показать. Возможны два сценария:

- **Тот же инпут, меняется текст:** один инпут обслуживает несколько типов событий (например, Сетбол А, Матчбол А, Таймаут А). При переходе «сетбол → таймаут» в том же инпуте просто меняется текст (и при необходимости цвет/логотип) на «Таймаут». На экране одна плашка, содержимое обновляется.
- **Другой инпут, показывается дополнительно:** таймаут выведен в отдельном инпуте (другой оверлей). При таймауте во время сетбола на экране одновременно видны и плашка «Сетбол» (или «Матчбол»), и плашка «Таймаут А/Б» — надписи сетбол/матчбол остаются.

Поведение задаётся **флажками в настройках инпута** (режим работы автоматического инпута):

- **«Заменять другие событийные плашки»** (или «Один слот: текст меняется»): при показе этого инпута он считается единственным активным событийным инпутом для своего набора типов; при смене события (например, сетбол → таймаут) содержимое этого инпута обновляется, другие авто-инпуты для того же «слота» не показываются. Подходит для схемы «один инпут на все события команды А» с подстановкой текста.
- **«Показывать совместно с другими событийными плашками»** (или «Дополнительный оверлей»): этот инпут показывается **в дополнение** к уже показанным событийным плашкам. Например, инпут только для «Таймаут А»/«Таймаут Б» с этим флагом — при таймауте во время сетбола отображаются и инпут «Сетбол», и инпут «Таймаут А» (два оверлея). Надписи сетбол/матчбол не снимаются.

В конфиге: флаг вроде `autoEventShowAlongside: true | false` (по умолчанию `false` — режим «замена»). Логика показа: инпуты с `autoEventShowAlongside: false` образуют «основной слот» (показываем не более одного такого за раз по приоритету события, обновляя содержимое); инпуты с `autoEventShowAlongside: true` добавляются поверх (показываем все такие инпуты, чьи отмеченные типы событий активны, без снятия других). Поскольку один тип события = один инпут, выбор сценария «тот же инпут» или «дополнительный» задаётся тем, на каком инпуте стоит галочка для этого типа и какой у инпута режим.

---

### Варианты: как отмечать инпут со счётом

**Вариант 1: Галка в настройках инпута**

- В карточке каждого инпута на странице «Настройки vMix» — чекбокс **«Использовать как инпут со счётом»**.  
- Только у одного инпута может быть включена эта галка (при включении у одного снимать у остальных, т.е. поведение как у радио).  
- **Плюс:** всё в одном месте, видно сразу, какой инпут счёт. **Минус:** при большом списке инпутов нужно найти нужный и поставить галку.

**Вариант 2: Отдельное поле с выпадающим списком**

- В блоке настроек vMix (например, вверху или в отдельной секции «Событийные плашки») поле **«Инпут со счётом»** с выпадающим списком всех настроенных инпутов (по displayName или имени).  
- **Плюс:** явно одно место выбора счёта, удобно при многих инпутах. **Минус:** дублирование информации (инпут уже есть в списке инпутов).

**Рекомендация:** можно реализовать **вариант 1** (галка) как основной; при желании позже добавить вариант 2 или комбинировать (например, галка на инпуте + в блоке «События» подпись «Инпут со счётом: [название]» только для отображения).

---

### Таймаут: состояние в приложении и кнопки на странице «Управление матчем»

- **Состояние:** хранить в приложении флаг «идёт таймаут» и команду (А или Б), по аналогии с сетболом/матчболом (например, в домене матча/партии или в useMatch).
- **Кнопки:** две кнопки **«Таймаут А»** и **«Таймаут Б»** — **только toggle** (нажал — таймаут начался, нажал снова — закончился). Авто-окончание по длительности (30 сек) в первой версии не реализуем.
- **Расположение на странице «Управление матчем»:**  
  - Рядом с блоком подачи (Serve) или счётчиков — компактный блок «Таймауты» с двумя кнопками.  
  - Либо в одной строке с основными действиями (счёт, подача), если места достаточно.  
  - Либо под/над блоком «Управление плашками vMix», чтобы логически связать «таймаут» и «событийные плашки».  
  Конкретное место можно зафиксировать при проработке макета (важно: не перегрузить верхнюю часть страницы).

---

### Предполагаемая структура настроек (эскиз)

- **Инпут со счётом:** один инпут помечен как счёт (`isScoreInput: true` или выбор в поле «Инпут со счётом»). По нему берётся номер оверлея для проверки «счёт выведен». Только один инпут со счётом; при отсутствии помеченного — авто-показ не запускаем.
- **Автоматический инпут:** у инпута `autoEvent: true`, галочки по шести типам событий (`autoEventTypes` или шесть флагов), флаг **режима** `autoEventShowAlongside: true | false` (см. раздел выше: замена vs дополнительный оверлей). Поля инпута сопоставляются обычным образом; для текста «Сетбол»/«Матчбол»/«Таймаут» в карту данных добавлено поле **«Автособытие»** (ключ, например `event.autoLabel`), его можно сопоставить с любым текстовым полем титра.
- **Один тип события = один инпут:** в настройках не допускаем, чтобы один и тот же тип события (например, «Сетбол А») был отмечен у нескольких инпутов. При выборе галочки на инпуте для типа, уже выбранного у другого инпута, — снимать галочку с другого (или запрещать выбор в UI).
- **Логика показа:** инпуты с `autoEventShowAlongside: false` — «основной слот»: по приоритету событий показываем не более одного такого инпута, обновляя его содержимое при смене события. Инпуты с `autoEventShowAlongside: true` — показываем все, у которых отмеченное событие активно (дополнительно к основному слоту). Таймаут во время сетбола: если таймаут — тот же инпут с галочками «Сетбол А» и «Таймаут А» (режим замена) — меняем текст на «Таймаут»; если таймаут — отдельный инпут с флагом «показывать совместно» — показываем оба оверлея. Скрытие только в связи с отображением счёта и окончанием событий; при завершении матча плашки явно не скрываем (достаточно связи с оверлеем счёта).

---

### Принятые решения по пунктам «Что ещё уточнить»

| Пункт | Решение |
|-------|---------|
| 1. Таймаут во время сетбола/матчбола | Показывать таймаут (команда может запросить таймаут при сетболе/матчболе). Режим задаётся флажками: **тот же инпут** (текст меняется) или **другой инпут** (дополнительный оверлей, надписи сетбол/матчбол остаются). См. раздел «Режим автоматического инпута». |
| 2. Длительность таймаута | Пока только **toggle** (вкл/выкл кнопкой). |
| 3. Таймаут и сетбол/матчбол | Зависит от распределения галочек и режима инпутов: при «дополнительном» инпуте под таймаут — на экране и сетбол/матчбол, и таймаут; при «замене» — один инпут, текст под текущее событие. |
| 4. Конец матча | **Не** скрывать авто-плашки явно при завершении матча. Достаточно связи с отображением счёта (оверлей счёта выключен — авто не показываем). |
| 5. Валидация | Только один инпут со счётом. При отсутствии инпута со счётом — авто-показ **не запускаем**. |
| 6. Несколько инпутов на один тип | **Один тип события = один инпут.** В UI не давать выбрать тип, уже выбранный у другого инпута (или при выборе снимать с другого). |
| 7. Обратная совместимость | По возможности предусмотреть (старые конфиги без `isScoreInput`/`autoEvent` — авто-логика не запускается), но не критично. |

---

## Дополнительные шаги для реализации

1. **Данные матча:** ввести и хранить состояние таймаута в приложении (команда А/Б, идёт/не идёт); единообразно определять «текущее событие» (нет / сетбол / матчбол / таймаут) с учётом приоритета.
2. **Справочник данных:** в `dataMapCatalog` и `getValueByDataMapKey` добавить поле **«Автособытие»** (ключ, например `event.autoLabel`). При разрешении значения для авто-инпута передавать **контекст по типу события** (для какого события показывается этот инпут) и возвращать «Сетбол»/«Матчбол»/«Таймаут» в зависимости от контекста, а не от глобального «текущего события», чтобы при двух инпутах на экране (сетбол + таймаут) у каждого был свой текст. При необходимости — дополнительные ключи для цвета/логотипа по событию с тем же контекстом.
3. **Настройки vMix (конфиг и UI):** отметка «инпут со счётом» (галка на инпуте или выпадающий список); для автоматических инпутов — флаг, галочки по шести типам событий, флаг режима «показывать совместно с другими» (`autoEventShowAlongside`); правило «один тип события = один инпут» (в UI не допускать дублирования типа по инпутам); сопоставление полей с ключами `event.*` (один набор на инпут).
4. **Страница «Управление матчем»:** кнопки «Таймаут А» и «Таймаут Б» (только toggle); при нажатии «выключить счёт» дополнительно скрывать все автоматические инпуты; в блоке «Управление плашками vMix» показывать авто-инпуты с пометкой «автоматический», с возможностью ручного показа.
5. **Логика useVMix (или отдельный хук):** инпуты с режимом «замена» — один «слот», содержимое по приоритету события; инпуты с режимом «дополнительный» — показывать все, чьи типы событий активны. Показ/скрытие только в связи с оверлеем счёта и окончанием событий; при завершении матча авто-плашки явно не скрывать.
6. **Документация:** после реализации обновить архитектуру и справочник API (новые dataMapKey, описание инпута со счётом и автоматических инпутов, Clear All в vMix, ссылка на vMix help29).

Подробный поэтапный план для программиста (TDD, тесты, обратная совместимость): **[План реализации: автособытия vMix](vmix-event-overlays-implementation-plan.md)**.
