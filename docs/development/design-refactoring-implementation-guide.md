# Инструкции по рефакторингу дизайна vMix Volley Scoreboard

*Документ содержит пошаговые инструкции по рефакторингу только визуальной части приложения (дизайн) без изменения функционала. Основан на [Аудите UI/UX](ui-ux-audit-report.md).*

*Последнее обновление: 2026-02-05*

**Этапы рефакторинга выполнены.** Текущее состояние системы дизайна (токены, темы, компоненты, оформление страниц) описано в **[Дизайн и темы](DESIGN.md)**. Данный файл сохранён как историческая справка по этапам и тестам.

---

## 1. Назначение и границы рефакторинга

### 1.1. Цель

- Ввести единую систему дизайна (design tokens).
- Унифицировать стили (цвета, отступы, типографика, кнопки).
- Добавить тёмную тему и улучшить доступность (фокус, контраст).
- Адаптировать компоновку под разрешение 1366×768 (только отступы/компактность).
- Привести мобильную панель к тем же токенам и теме.

**Функционал приложения не меняется:** те же экраны, те же кнопки и поля, те же обработчики и API. Меняются только стили, тема и при необходимости разметка (например, замена `<button style={...}>` на `<Button variant="primary">` с тем же `onClick` и `disabled`).

### 1.2. Что считаем «дизайном» (можно менять)

| Категория | Примеры |
|-----------|---------|
| Цвета | Фоны, границы, цвет текста, кнопок, акцентов |
| Отступы и размеры | padding, margin, gap, maxWidth, размеры шрифтов |
| Типографика | fontFamily, fontSize, fontWeight (без изменения текста) |
| Визуальные состояния | :hover, :focus, outline; стили disabled |
| Тема | Светлая/тёмная; значения токенов по темам |
| Структура стилей | Замена inline-стилей на классы или токены; введение компонента Button (с теми же пропсами по смыслу: onClick, disabled, children) |
| Компактность | Уменьшение отступов, свёртка блока «Расширенная статистика» по умолчанию (раскрытие по клику — поведение остаётся) |

### 1.3. Что не меняем (функционал)

| Запрещено | Пояснение |
|-----------|-----------|
| Текст и подписи | Надписи на кнопках, заголовки страниц, лейблы полей, сообщения об ошибках — без изменений (п. 3.6 аудита — уточнение формулировок выносим за рамки этого рефакторинга или делаем опционально). |
| Логика и API | Обработчики событий, вызовы IPC, структура матча, валидация, правила волейбола — без изменений. |
| Структура экранов | Не добавляем и не убираем страницы; не разбиваем формы на вкладки/шаги (только компактнее отступы внутри существующих блоков). |
| Навигация | Меню, маршруты, кнопки перехода — те же пункты и те же переходы. |
| Данные и настройки | Формат settings.json, структура матча, поля инпутов vMix — без изменений. Исключение: добавление в настройки ключа темы (например, `ui.theme`) — это расширение, не ломающее старые сценарии. |

### 1.4. Риски и как их снижать

- **Случайная поломка поведения:** при замене разметки (например, на `<Button>`) сохранять те же `onClick`, `disabled`, `type`, `children` и доступность (роли, имена). После каждого этапа — полный прогон тестов.
- **Визуальный регресс:** перед началом можно зафиксировать скриншоты ключевых экранов (вручную или скриптом) и сравнивать после этапов; в документе достаточно опоры на автотесты и ручную проверку.
- **Мобильная панель:** изменения только в CSS/токенах и (при введении темы) в подставляемых в HTML значениях; логика в `<script>` не трогаем.

---

## 2. Стратегия тестирования

### 2.1. Существующие тесты — основа

- Юнит-тесты проверяют наличие элементов (по тексту, по роли), вызов колбэков при клике и т.д. Они **не привязаны к конкретным значениям цветов или отступов**.
- После **каждого этапа** обязательно: `npm test`. Все тесты должны оставаться зелёными. Если тест упадёт — откатить последние изменения в разметке/компонентах и сохранить прежнее поведение (те же роли, те же тексты, те же обработчики).

### 2.2. Что добавляем для рефакторинга дизайна

1. **Не добавляем** тесты на конкретные CSS-значения (цвета, пиксели) — они сделают рефакторинг хрупким.
2. **Рекомендуется** для ключевых UI-компонентов:
   - проверять, что компонент рендерится без ошибок;
   - проверять наличие ожидаемых элементов (кнопки, поля, заголовки) по роли или по тексту (как уже делается в ScoreButtons, SetsDisplay и др.).
3. **Опционально:** один интеграционный или E2E-сценарий «открыть приложение → загрузить матч → нажать +1 → проверить обновление счёта» для финальной проверки (если такой тест уже есть — опираться на него).

### 2.3. Чек-лист после каждого этапа

- [ ] `npm test` — все тесты зелёные.
- [ ] Ручная проверка: запуск приложения (`npm run dev` или сборка), проход по основным экранам (Главная, Управление матчем, Настройки матча, Настройки vMix, Составы, Мобильный доступ).
- [ ] Для этапов с темой: переключение светлой/тёмной темы и проверка читаемости.
- [ ] Для мобильной панели: открытие `/panel/:sessionId` в браузере, проверка счёта и кнопок.

---

## 3. Зависимости этапов

Рефакторинг разбит на фазы так, чтобы каждая опиралась на предыдущие и не трогала функционал.

```
Этап 0: Подготовка и гигиена
    ↓
Этап 1: Design tokens (модуль констант)
    ↓
Этап 2: Подключение токенов в приложение (без смены внешнего вида)
    ↓
Этап 3: Замена inline-стилей на токены по компонентам
    ↓
Этап 4: Компонент Button и унификация кнопок
    ↓
Этап 5: Цвет счёта/подачи от цвета команды
Этап 6: Доступность (focus, контраст)
    ↓ (параллельно или после 3–4)
Этап 7: Тёмная тема (десктоп + мобильная)
Этап 8: Компактность для 1366×768
```

---

## 4. Этап 0: Подготовка и гигиена

**Цель:** создать ветку, зафиксировать зелёные тесты, убрать отладочный вывод, не трогая стили.

**Файлы:** `src/renderer/components/SetsDisplay.jsx`, репозиторий.

### 4.1. Шаги

1. Создать ветку (например, `feature/design-refactoring`). Убедиться, что `main` в порядке: `npm test`.
2. Удалить или обернуть в `import.meta.env.DEV` вызов `console.log` в `SetsDisplay.jsx` (в рендере). Запустить тесты: `npm test`. Убедиться, что тесты для SetsDisplay по-прежнему проходят.
3. (Опционально) Зафиксировать текущие скриншоты ключевых страниц для последующего визуального сравнения.

### 4.2. Критерий готовности

- Все тесты зелёные.
- В продакшен-сборке в консоли нет лишнего вывода из SetsDisplay.

---

## 5. Этап 1: Design tokens (модуль констант)

**Цель:** ввести один модуль с константами цветов, отступов, радиусов и типографики. Пока не подключать их к компонентам — только определить и протестировать экспорт.

**Функционал:** не затрагивается.

### 5.1. Файлы

- Создать: `src/renderer/theme/tokens.js` (или `src/shared/theme/tokens.js` при желании использовать токены и в main для мобильной панели).

### 5.2. Структура токенов (рекомендуемая)

```javascript
// Светлая тема (текущий визуал)
export const light = {
  // Фоны
  background: '#f5f5f5',
  surface: '#ffffff',
  surfaceMuted: '#ecf0f1',
  // Текст
  text: '#2c3e50',
  textSecondary: '#7f8c8d',
  // Акценты и кнопки
  primary: '#3498db',
  primaryHover: '#2980b9',
  success: '#27ae60',
  successHover: '#229954',
  danger: '#e74c3c',
  dangerHover: '#c0392b',
  warning: '#f39c12',
  neutral: '#95a5a6',
  neutralHover: '#7f8c8d',
  // Границы и разделители
  border: '#bdc3c7',
  borderStrong: '#3498db',
  // Специальные
  headerBg: '#2c3e50',
  disabled: '#bdc3c7',
};

// Тёмная тема (значения задать на этапе 7)
export const dark = {
  background: '#1a1a2e',
  surface: '#16213e',
  surfaceMuted: '#0f3460',
  text: '#e8e8e8',
  textSecondary: '#a0a0a0',
  primary: '#3498db',
  primaryHover: '#5dade2',
  success: '#27ae60',
  successHover: '#2ecc71',
  danger: '#e74c3c',
  dangerHover: '#ec7063',
  warning: '#f39c12',
  neutral: '#7f8c8d',
  neutralHover: '#95a5a6',
  border: '#2c3e50',
  borderStrong: '#3498db',
  headerBg: '#0f0f1a',
  disabled: '#4a4a4a',
};

// Отступы (общие для тем)
export const space = {
  xs: '0.25rem',
  sm: '0.5rem',
  md: '1rem',
  lg: '1.5rem',
  xl: '2rem',
};

export const radius = {
  sm: '4px',
  md: '8px',
  lg: '12px',
};

// Типографика (опционально)
export const typography = {
  fontFamily: 'system-ui, -apple-system, sans-serif',
  h1: '2.5rem',
  h2: '1.5rem',
  h3: '1.25rem',
  h4: '1rem',
  body: '1rem',
  small: '0.9rem',
  caption: '0.85rem',
};
```

### 5.3. Тесты для токенов

- Создать `tests/unit/renderer/theme/tokens.test.js` (или `tests/unit/shared/theme/tokens.test.js`).
- Проверки:
  - `light` и `dark` экспортируются и содержат одни и те же ключи.
  - У каждого ключа в `light` и `dark` — непустая строка (цвет или размер).
  - `space` и `radius` содержат ожидаемые ключи (xs, sm, md, lg и т.д.).

### 5.4. Критерий готовности

- Модуль создан, тесты на токены зелёные. Компоненты пока не импортируют токены.

---

## 6. Этап 2: Подключение токенов в приложение (без смены вида)

**Цель:** подключить токены так, чтобы текущий вид не изменился. Варианты: (A) передавать в компоненты через контекст или (B) задать CSS-переменные на корне из `light` и подключать их в следующих этапах.

Рекомендация: **вариант (B)** — в `index.html` или в корневом компоненте (App/Layout) при монтировании установить на `document.documentElement` набор переменных из `light`, например:

```javascript
--color-background: #f5f5f5;
--color-surface: #ffffff;
--color-primary: #3498db;
...
```

Тогда на этапе 3 можно постепенно заменять inline-стили на `var(--color-background)` и т.д., а на этапе 7 — переключать набор переменных при смене темы.

### 6.1. Шаги

1. Добавить в проект утилиту применения темы к DOM, например `src/renderer/theme/applyTheme.js`:
   - функция `applyTheme(themeObject)` принимает объект типа `light` или `dark` и записывает в `document.documentElement.style` свойства вида `--color-background`, `--color-surface`, … (маппинг ключей токенов в имена CSS-переменных).
2. В точке входа (например, в `App.jsx` в `useEffect`) вызвать `applyTheme(light)` при монтировании.
3. Убедиться, что после запуска приложения внешний вид не изменился (пока компоненты ещё не используют переменные). Запустить тесты.

### 6.2. Критерий готовности

- CSS-переменные заданы на корне при старте. Все тесты зелёные. Визуально приложение как до рефакторинга.

---

## 7. Этап 3: Замена inline-стилей на токены по компонентам

**Статус: выполнено.** Все перечисленные компоненты и страницы переведены на токены (CSS-переменные и импорт space/radius/typography). Добавлены токены: accent, accentHover, overlay, primaryLight.

**Цель:** по одному компоненту/странице заменить жёстко заданные цвета и отступы на значения из токенов (через CSS-переменные или прямой импорт). Поведение и тексты не менять.

**Порядок (от общего к частному):**

1. **Layout.jsx** — шапка, фон main, отступы. Заменить `#2c3e50`, `#f5f5f5`, padding/margin на переменные или константы из токенов.
2. **WelcomePage.jsx** — фон, кнопки, типографика.
3. **MatchControlPage.jsx** — фон блоков, границы, кнопки (пока без компонента Button — только подстановка цветов/отступов из токенов).
4. **MatchSettingsPage.jsx** — карточки, поля, кнопки.
5. **VMixSettingsPage.jsx** — то же.
6. **VMixOverlayButtons.jsx**, **VMixInputFieldsPanel.jsx** — панели и кнопки.
7. **RosterManagementPage.jsx** — таблица, кнопки.
8. **MobileAccessPage.jsx**, **AboutPage.jsx**.
9. Компоненты: **ScoreDisplay.jsx**, **SetsDisplay.jsx**, **ScoreButtons.jsx**, **ServeControl.jsx**, **StatusIndicators.jsx**, **SetEditModal.jsx**, **ErrorBoundary.jsx**.

Для каждого файла:

- Заменить только значения в `style={{ ... }}` (или в объекте стилей). Не менять структуру JSX (количество кнопок, порядок полей, обработчики).
- После правки файла: `npm test`. При падении теста — вернуть прежнюю разметку/роли и оставить только подстановку стилей.

### 7.1. Критерий готовности

- Все перечисленные компоненты и страницы используют токены (или CSS-переменные из токенов). Тесты зелёные. Визуально — как раньше (светлая тема).

---

## 8. Этап 4: Компонент Button и унификация кнопок

**Статус: выполнено.** Создан `src/renderer/components/Button.jsx` с вариантами primary, secondary, success, danger, warning, accent. Добавлены тесты `tests/unit/renderer/Button.test.jsx`. Кнопки заменены на `<Button>` во всех страницах и компонентах (WelcomePage, MatchControlPage, MatchSettingsPage, VMixSettingsPage, RosterManagementPage, MobileAccessPage, AboutPage, SetEditModal, ScoreButtons, VMixOverlayButtons). Кнопки выбора команды A/B в RosterManagementPage оставлены нативными из‑за динамического цвета команды.

**Цель:** ввести переиспользуемый компонент `Button` с вариантами (например, `primary`, `secondary`, `danger`) и заменить им существующие кнопки, сохраняя те же `onClick`, `disabled`, `children` и доступные имена (для скринридеров).

**Функционал:** не меняется — только способ задания стилей.

### 8.1. Компонент Button

- Создать `src/renderer/components/Button.jsx`.
- Пропсы: `variant` ('primary' | 'secondary' | 'danger' | 'success'), `disabled`, `onClick`, `type`, `children`, опционально `className`, `style` (для переопределения), `aria-label` при необходимости.
- Рендер: один `<button>`, стили берутся из токенов по `variant`. Сохранять `type="button"` по умолчанию, если сейчас не `submit`.

### 8.2. Тесты для Button

- Файл: `tests/unit/renderer/Button.test.jsx`.
- Проверки: рендер с разными `variant`; при клике вызывается `onClick`; при `disabled` клик не вызывает `onClick`; доступность (роль button, возможность задать aria-label).

### 8.3. Замена по экранам

Заменять по одному месту: вместо `<button onClick={...} style={{...}}>Текст</button>` использовать `<Button variant="primary" onClick={...}>Текст</Button>`. Не менять порядок кнопок и не объединять/разделять действия. После каждой страницы/компонента — `npm test`.

### 8.4. Критерий готовности

- Все кнопки (кроме нативных в формах, если нужен явный submit) используют `Button`. Тесты зелёные, в том числе существующие тесты страниц (кнопки по-прежнему находятся по роли и тексту).

---

## 9. Этап 5: Выделение подающей команды (без смены цвета счёта)

**Статус: выполнено.** В ScoreDisplay: цвет счёта и имён — единый нейтральный (var(--color-text)); для подающей стороны добавлена рамка 2px в цвете команды и бейдж «Подача» с фоном teamColor и контрастным текстом. В ServeControl: имя подающей команды выведено бейджем с фоном в цвете команды и getContrastTextColor. Пропсы teamAColor/teamBColor передаются из MatchControlPage. Кнопки стрелок в ServeControl заменены на Button с aria-label.

**Цель:** убрать жёсткий оранжевый цвет для подающей команды и согласовать индикацию подачи с цветом команды или с нейтральным, но понятным способом. **Рекомендуется не менять цвет самих цифр счёта** — оставить их в одном нейтральном цвете и выделять подачу отдельным приёмом (см. ниже).

**Функционал:** не меняется.

### 9.0. Пояснение: контраст и два подхода

**Как работает `getContrastTextColor(backgroundColor)`:** функция принимает **цвет фона** и возвращает цвет текста (чёрный или белый) для читаемости на этом фоне. То есть она рассчитана на ситуацию «текст поверх цветного фона», а не «цветной текст на светлом фоне». Если бы мы красили **цифры счёта** в цвет команды, то при светлом цвете команды (например, жёлтом) текст на белом фоне карточки стал бы нечитаемым, и контраст мы бы не гарантировали без дополнительной логики.

**Вариант A — цвет команды как фон под счётом:**  
Для подающей команды задать блоку с именем и счётом **фон** `teamA.color` / `teamB.color`, а цвет текста взять как `getContrastTextColor(teamColor)`. Цифры счёта тогда всегда читаемы, цвет команды виден. Минус: крупный цветной прямоугольник рядом со счётом может визуально перегружать блок и «перетягивать» внимание.

**Вариант B (рекомендуемый) — цвет счёта не менять, подачу показывать отдельно:**  
Цифры счёта и названия команд остаются в одном нейтральном цвете (например, `#2c3e50` или токен `text`). Подающую команду выделяем **не цветом счёта**, а одним из приёмов ниже. Так контраст и читаемость счёта не зависят от цвета команды, а связь «кто подаёт» с командой можно дать через небольшой акцент в цвете команды (иконка, рамка, бейдж).

### 9.1. Рекомендуемый вариант с точки зрения UI: альтернативное выделение подачи

Оставить **цвет счёта единым** для обеих команд (нейтральный тёмный). Подающую команду выделять одним (или комбинацией) из способов:

| Способ | Описание | Плюсы | Минусы |
|--------|----------|--------|--------|
| **Иконка «мяч» или «подача»** | Небольшая иконка (например, круг/мяч) рядом с названием команды или под счётом только у подающей стороны. Иконку можно окрасить в цвет команды (`teamColor`), при необходимости поместить в круг с фоном `teamColor` и текстом `getContrastTextColor(teamColor)` (если иконка не пиктограмма, а буква «П»). | Сразу понятно «кто подаёт», цвет команды виден на маленьком элементе, счёт не трогаем. | Нужна простая иконка или символ. |
| **Рамка/кольцо в цвете команды** | У блока «команда + счёт» подающей стороны — тонкая рамка (2px) или «кольцо» в `teamA.color`/`teamB.color`. Фон блока остаётся светлым, цифры — нейтральные. | Минимум изменений, цвет команды виден, контраст счёта не страдает. | При очень светлом цвете команды рамка может быть малозаметной. |
| **Бейдж «Подача»** | Под названием команды или рядом с счётом маленькая плашка «Подача» с фоном в цвет команды и текстом `getContrastTextColor(teamColor)`. | Явная подпись, хороший контраст за счёт фона. | Занимает место. |
| **Акцентная линия под названием** | Короткая линия (underline) под названием команды в цвете команды, только у подающей стороны. | Очень лаконично, цвет команды виден. | Легко не заметить при быстром взгляде. |

**Рекомендация:** использовать **рамку/кольцо в цвете команды** вокруг блока подающей стороны (название + счёт) — без смены фона и без смены цвета цифр. Опционально добавить небольшую иконку «мяч» или текст «Подача» рядом с названием команды, если хочется ещё более явной подсказки. В блоке **ServeControl** имя подающей команды можно оставить выделенным цветом команды (там маленький объём текста) или тоже оформить как бейдж с фоном `teamColor` и контрастным текстом.

### 9.2. Шаги реализации (рекомендуемый вариант)

1. **ScoreDisplay.jsx**
   - Убрать смену цвета текста для подающей команды: не использовать `#f39c12` для имени и счёта. Для обеих команд использовать один нейтральный цвет (токен `text` или текущий `#34495e`).
   - Для подающей команды: обернуть блок (название + счёт) в контейнер с тонкой рамкой (2px solid) в цвете команды: `teamA.color` / `teamB.color`. При необходимости задать `borderRadius`, чтобы визуально «подсветить» только подающую сторону.
   - Опционально: рядом с названием подающей команды вывести маленький бейдж «Подача» с фоном `teamColor` и текстом `getContrastTextColor(teamColor)`.
   - Индикаторы «СЕТБОЛ»/«МАТЧБОЛ» оставить как есть (или при желании привязать фон к цвету команды и текст к `getContrastTextColor`).

2. **ServeControl.jsx**
   - Вместо жёсткого оранжевого для имени подающей команды: либо использовать цвет команды для текста (если передать `teamAColor`/`teamBColor` и выбрать цвет текущей подающей команды; для светлых цветов контраст на сером фоне может падать — тогда лучше бейдж), либо оставить нейтральный акцент (например, жирный текст + маленький бейдж «Подача» с фоном в цвете команды и контрастным текстом). Предпочтительно: бейдж с `teamColor` и `getContrastTextColor(teamColor)` для надписи имени или «Подача».

3. **Пропсы**
   - В ScoreDisplay и ServeControl при необходимости передать `teamAColor` и `teamBColor` (из матча), чтобы рисовать рамку и бейдж в цвете команды. Если цветов нет — fallback на нейтральный акцент (например, токен `primary` или тонкая серая рамка).

4. **Мобильная панель (server.ts)**
   - Аналогично: не красить цифры счёта в цвет команды; для подающей стороны добавить в разметку/стили рамку или бейдж в цвете команды (значения подставлять из данных матча). Контраст текста на бейдже — через тот же подход (фон = teamColor, текст = контрастный).

5. **Тесты**
   - Запустить `npm test`. Убедиться, что тесты, проверяющие наличие счёта и имён команд, по-прежнему проходят (структура и тексты не меняются, меняется только оформление).

### 9.3. Критерий готовности

- Цвет цифр счёта не зависит от подачи и одинаков для обеих команд (нейтральный). Подающая команда выделена рамкой и/или бейджем/иконкой в цвете команды. В ServeControl имя подающей команды оформлено без жёсткого оранжевого (цвет команды или бейдж с контрастным текстом). Тесты зелёные.

---

## 10. Этап 6: Доступность (focus, контраст)

**Статус: выполнено.** В `index.html` добавлены глобальные стили `:focus-visible` для button, input, select, textarea, a: outline 2px solid var(--color-primary), outline-offset 2px; для :focus без :focus-visible — outline: none. В ServeControl кнопкам стрелок заданы aria-label.

**Цель:** добавить видимые стили фокуса для кнопок и полей ввода; при необходимости скорректировать контраст (в рамках токенов).

**Функционал:** не меняется.

### 10.1. Фокус

- В глобальных стилях (например, в `index.html` в `<style>` или в отдельном CSS-файле, подключённом в renderer) добавить:
  - `button:focus-visible`, `input:focus-visible`, `select:focus-visible` — `outline: 2px solid var(--color-primary); outline-offset: 2px;` (или эквивалент из токенов). При необходимости сбросить `outline: none` только для `:focus` и задать стиль для `:focus-visible`.
- Убедиться, что при навигации с клавиатуры (Tab) фокус виден. Не менять логику табуляции.

### 10.2. Контраст

- Проверить пару «вторичный текст» — «фон» (например, `textSecondary` на `surfaceMuted`) по WCAG AA. Если контраст недостаточен — скорректировать значения в `light` (и позже в `dark`) в токенах. Компоненты уже используют токены — менять ничего не нужно.

### 10.3. aria-label

- Добавить `aria-label` только там, где кнопка содержит только иконку или короткий текст вроде «◄»/«►» и смысл неочевиден. Не менять видимый текст кнопок.

### 10.4. Критерий готовности

- Фокус виден при Tab. Контраст проверен. Тесты зелёные.

---

## 11. Этап 7: Тёмная тема (десктоп + мобильная панель)

**Статус: выполнено.** В settingsManager добавлена секция ui.theme ('light'|'dark'|'system'), валидация в settingsValidator, IPC ui:get-settings / ui:set-settings, preload getUISettings/setUISettings и onUIThemeChanged. В App загрузка темы при старте, применение applyTheme(light/dark), переключатель в Layout (кнопка «Тёмная»/«Светлая»). Мобильная панель: маршрут /panel/:sessionId асинхронно читает ui.theme, в getMobilePanelHTML передаётся theme, на body выставляется data-theme="dark", добавлены стили [data-theme="dark"] для тёмной панели. Добавлен тест applyTheme.

**Цель:** дать пользователю возможность переключать светлую/тёмную тему. Хранение выбора в настройках; применение на десктопе и в мобильной панели.

**Функционал:** добавляется только переключатель темы и чтение/запись настройки; остальное поведение без изменений.

### 11.1. Настройки

- В `settingsManager` (и в схеме валидации) добавить опциональную секцию `ui` с полем `theme: 'light' | 'dark' | 'system'`. По умолчанию — `'light'` или `'system'`.
- В preload/main добавить IPC для чтения и записи этой настройки (или она входит в общий объект настроек). Сохранять в тот же `settings.json`.

### 11.2. Десктоп (React)

- В контексте или в App при загрузке читать `ui.theme`. Если `'system'` — использовать `window.matchMedia('(prefers-color-scheme: dark)')` для выбора текущей темы.
- Вызывать `applyTheme(theme === 'dark' ? dark : light)` и при смене темы обновлять DOM (и при необходимости сохранять настройку).
- Переключатель темы: в меню «Вид» или в шапке Layout. При клике — переключить тему, сохранить в настройки, применить токены.

### 11.3. Мобильная панель

- При генерации HTML в `getMobilePanelHTML` читать из настроек `ui.theme` (или передавать query-параметр). Либо на клиенте в странице панели определять тему через `prefers-color-scheme` и применять класс к `body` (например, `data-theme="dark"`).
- В том же HTML добавить второй блок стилей для `[data-theme="dark"]` (или переопределение CSS-переменных), используя значения из того же объекта `dark` в shared/theme (если токены вынесены в shared) или продублировать значения в server.ts только для стилей. Цель — не менять логику скрипта, только подставлять класс или набор переменных.

### 11.4. Тесты

- Юнит-тест: применение темы (applyTheme) устанавливает ожидаемые CSS-переменные на documentElement.
- Опционально: тест на то, что переключатель темы вызывает сохранение настройки и смену темы (с моками IPC/settings).

### 11.5. Критерий готовности

- Переключение темы на десктопе сохраняется и применяется. Мобильная панель отображает светлую/тёмную тему. Все тесты зелёные.

---

## 12. Этап 8: Компактность для 1366×768

**Статус: выполнено.** На MatchControlPage введено состояние statsExpanded (по умолчанию false). Блок «Расширенная статистика» по умолчанию свёрнут; добавлена кнопка «Развернуть»/«Свернуть», содержимое (сетка статистики) отображается только при statsExpanded && match.statistics.enabled.

**Цель:** уменьшить вертикальную прокрутку на типичном разрешении без изменения структуры форм и навигации.

**Допустимые изменения:**

- Уменьшить отступы (margin, padding, gap) в пределах значений из токенов (например, использовать `space.sm` вместо `space.md` там, где это не вредит читаемости).
- Блок «Расширенная статистика» на странице «Управление матчем» по умолчанию сделать свёрнутым; при клике — раскрывать. Содержимое и логика (включение/выключение статистики, кнопки ±1) не меняются — меняется только начальное состояние «свёрнут/развёрнут».
- Не добавлять вкладки и шаги в формах; не убирать поля.

### 12.1. Шаги

1. На MatchControlPage ввести локальное состояние `statsExpanded` (по умолчанию `false`). Обернуть блок расширенной статистики в раскрывающийся контейнер: заголовок с кнопкой «Развернуть/Свернуть» и условный рендер содержимого. Существующие тесты, проверяющие наличие кнопок статистики, должны по-прежнему проходить (например, перед проверкой раскрыть блок или искать в документе без учёта видимости — в зависимости от реализации тестов).
2. На страницах настроек и составов заменить часть отступов на меньшие из токенов. Проверить тесты и ручной проход.

### 12.2. Критерий готовности

- На 1366×768 основной контент страницы матча виден с меньшей прокруткой; расширенная статистика по умолчанию свёрнута. Тесты зелёные.

---

## 13. Этап 9: Мобильная панель — токены и тема

**Статус: выполнено.** Токены вынесены в `src/shared/theme/tokens.js` (light, dark, space, radius, typography). `src/renderer/theme/tokens.js` реэкспортирует их из shared. В `server.ts` импортируются light и dark из shared; при генерации HTML мобильной панели в `<style>` добавляется блок `:root { --color-*: ... }` из выбранной темы (light/dark), мобильная панель использует ту же тему из настроек ui.theme (как в этапе 7).

**Цель:** в HTML мобильной панели использовать те же цветовые и отступные значения, что и на десктопе (через подстановку при генерации или общий файл токенов), и поддержать тёмную тему (если не сделано в этапе 7).

### 13.1. Шаги

1. Вынести токены в модуль, доступный и из main (например, `src/shared/theme/tokens.js`). В `server.ts` импортировать `light` и `dark`.
2. При генерации HTML подставлять в `<style>` значения из `light` или `dark` (в зависимости от настройки темы или query-параметра). Например: генерировать блок `:root { --color-background: ${theme.background}; ... }` и в правилах использовать `var(--color-background)`.
3. Либо оставить текущие классы и заменить жёсткие значения в стилях на подстановки из объекта темы. Логику в `<script>` не трогать.

### 13.2. Критерий готовности

- Мобильная панель визуально согласована с десктопом (светлая/тёмная тема). Функционал панели не изменился. Интеграционные тесты мобильного API (если есть) зелёные.

---

## 14. Доработки после этапов 0–9 (обратная связь пользователя)

**Статус: выполнено.** Учтены замечания по тёмной теме и блоку счёта.

### 14.1. Цвет текста в тёмной теме

- В `index.html` для `body` и `#root` заданы `color: var(--color-text)` и `background-color: var(--color-background)`; добавлены fallback-значения светлой темы (`#2c3e50`, `#f5f5f5`) до применения темы из JS.
- В `applyTheme.js` тема применяется к `document.documentElement`, все токены (включая `text`, `textSecondary`) становятся CSS-переменными `--color-text`, `--color-text-secondary` и т.д.
- В `VMixInputFieldsPanel.jsx` захардкоженный цвет `#7f8c8d` заменён на `var(--color-text-secondary)`.

### 14.2. Тёмная тема — градации серого

- В `src/shared/theme/tokens.js` объект `dark` переведён на серые подложки: `background: #121212`, `surface: #252525`, `surfaceMuted: #383838`, `headerBg: #1a1a1a`, `text: #e8e8e8`, `textSecondary: #b0b0b0`, `primaryLight: #3a3a3a`.
- В мобильной панели (`server.ts`) тёмная тема использует те же градации серого вместо тёмно-синих блоков.

### 14.3. Рамка подающей команды — фиксированные цвета

- В токенах добавлены `servingBorder` и `servingBadge`: в светлой теме — синий (`#3498db`), в тёмной — `servingBorder: #5dade2`, `servingBadge: #3498db`, чтобы рамка и бейдж «Подача» были видны на любом фоне (в т.ч. белая форма на светлой подложке).
- В `ScoreDisplay.jsx` и `ServeControl.jsx` используются `var(--color-serving-border)` и `var(--color-serving-badge)`.

### 14.4. Стабильная вёрстка блока счёта

- В `ScoreDisplay.jsx` введена константа `TEAM_BLOCK_WIDTH = 200`: блокам команд заданы `width`, `minWidth`, `maxWidth`, чтобы ширина не зависела от длины названия и наличия бейджа «Подача».
- Для названия команды: `overflow: hidden`, `textOverflow: ellipsis`, `whiteSpace: nowrap`, `maxWidth: 100%` — длинные имена обрезаются с многоточием без переноса.
- У разделителя «:» задан `flexShrink: 0`.

### 14.5. Критерий готовности

- В тёмной теме весь текст читаем (основной и вторичный).
- Подложки в тёмной теме — серые, без тёмно-синих блоков.
- Рамка и бейдж подачи контрастны на светлой и тёмной подложке.
- Блок счёта не «прыгает» при разной длине имён и при включении бейджа «Подача».

---

## 15. Сводная таблица этапов и тестов

| Этап | Что делаем | Что проверяем |
|------|------------|----------------|
| 0 | Ветка, удаление console.log в SetsDisplay | `npm test` |
| 1 | Модуль токенов (light, dark, space, radius) | Юнит-тесты токенов |
| 2 | applyTheme(light), CSS-переменные на корне | Тесты + ручная проверка вида |
| 3 | Замена inline-стилей на токены по всем компонентам/страницам | `npm test` после каждого файла |
| 4 | Компонент Button, замена кнопок | Тесты Button + все существующие тесты |
| 5 | Цвет счёта/подачи от цвета команды в ScoreDisplay (и опционально мобильная) | Тесты счёта/матча |
| 6 | Стили focus, контраст, aria-label где нужно | `npm test`, ручная проверка Tab |
| 7 | Настройка темы, переключатель, тёмная тема в мобильной панели | Тесты applyTheme/настроек, ручная проверка обеих тем |
| 8 | Компактные отступы, свёртка «Расширенная статистика» | `npm test`, ручная проверка 1366×768 |
| 9 | Мобильная панель: подстановка токенов и темы в HTML | Тесты мобильного API, ручная проверка панели |

---

## 16. Порядок выполнения и откат

- Выполнять этапы строго по нумерации. При появлении падающих тестов — не переходить к следующему этапу до их исправления.
- Откат: по одному этапу откатывать коммиты и снова запускать тесты. Это позволит локализовать регрессию.
- После завершения всех этапов: полный прогон `npm test`, `npm run test:coverage`, ручная проверка всех страниц и мобильной панели в обеих темах. Обновить CHANGELOG и при необходимости [Аудит UI/UX](ui-ux-audit-report.md) (отметить выполненные пункты).
