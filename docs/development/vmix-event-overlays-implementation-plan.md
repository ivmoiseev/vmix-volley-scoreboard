# План реализации: автоматические плашки событий (сетбол, матчбол, таймаут) в vMix

*Последнее обновление: 2026-02-16*

Основа: [План и анализ автособытий vMix](vmix-event-overlays-setball-matchball-timeout.md).

Подход: **TDD** — сначала тесты (красный), затем реализация (зелёный), при необходимости рефакторинг. Покрытие тестами обязательно для изменяемого кода.

---

## Обзор изменений по модулям

| Модуль | Изменения |
|--------|-----------|
| **shared/types/Match.ts** | Опционально: поле состояния таймаута (timeoutTeam, timeoutActive или в currentSet). |
| **shared/getValueByDataMapKey.ts** | Опциональный контекст `options?: { eventType?: string }`; ключ `event.autoLabel` с разрешением по eventType. |
| **shared/dataMapCatalog.ts** | Новая группа или пункт «Автособытие» (ключ `event.autoLabel`). |
| **renderer/hooks/useMatch.ts** | Состояние таймаута (какая команда, идёт/не идёт), toggle таймаута; экспорт `timeoutTeam`, `isTimeoutNow`. |
| **main/utils/settingsValidator.ts** | Опциональные поля инпута: `isScoreInput`, `autoEvent`, `autoEventTypes`, `autoEventShowAlongside`; валидация «один тип события = один инпут» (при наличии autoEvent). |
| **renderer/pages/VMixSettingsPage.tsx** | Галка «Использовать как инпут со счётом»; для авто-инпутов: галочки по 6 типам событий, флаг «Показывать совместно с другими»; правило один тип = один инпут в UI. |
| **renderer/components/VMixOverlayButtons.tsx** | Пометка «автоматический» для авто-инпутов (ручной показ допускается). |
| **renderer/hooks/useVMix.ts** | Логика авто-показа: определение инпута со счётом, активных событий по приоритету, показ/скрытие авто-инпутов; при обновлении авто-инпута передавать контекст eventType в getValueByDataMapKey; при hideOverlay счёта — скрывать все авто-инпуты. |
| **renderer/pages/MatchControlPage.tsx** | Кнопки «Таймаут А», «Таймаут Б»; при нажатии «выключить счёт» вызывать скрытие авто-инпутов (через useVMix). |
| **main/vmix-overlay-utils.ts** | Опционально: хелперы «список авто-инпутов», «оверлей инпута со счётом» — только если понадобятся в main. |
| **main/main.ts** | Без изменений логики show/hide overlay; при необходимости экспорт списка ключей авто-инпутов для hide всех. |

---

## Константы и типы (общие)

Ввести в shared файл `src/shared/eventOverlayTypes.ts` с константами типов событий и порядком приоритета:

```ts
// Типы событий для авто-плашек (6 штук)
export const AUTO_EVENT_TYPES = ['setballA', 'setballB', 'matchballA', 'matchballB', 'timeoutA', 'timeoutB'] as const;
export type AutoEventType = typeof AUTO_EVENT_TYPES[number];

// Метки для отображения в поле «Автособытие»
export const AUTO_EVENT_LABELS: Record<AutoEventType, string> = {
  setballA: 'Сетбол',
  setballB: 'Сетбол',
  matchballA: 'Матчбол',
  matchballB: 'Матчбол',
  timeoutA: 'Таймаут',
  timeoutB: 'Таймаут',
};

// Приоритет для «основного слота»: при нескольких активных показываем первое по списку (таймаут > матчбол > сетбол)
export const AUTO_EVENT_PRIORITY_ORDER: AutoEventType[] = [
  'timeoutA', 'timeoutB', 'matchballA', 'matchballB', 'setballA', 'setballB'
];
```

Приоритет для «основного слота» (режим замена): **таймаут > матчбол > сетбол**. Так при одном инпуте с галочками на все типы во время таймаута (в т.ч. взятого при сетболе/матчболе) показывается «Таймаут»; без таймаута — сетбол или матчбол. Инпуты с `autoEventShowAlongside: true` показываются все по своим активным типам; с `false` — только один инпут, событие по приоритету.

---

## Этап 0: Подготовка типов и констант (TDD)

**Цель:** Единое место типов событий и меток для «Автособытие».

1. **Тесты** (например, `tests/unit/shared/eventOverlayTypes.test.ts`):
   - Все ключи из `AUTO_EVENT_LABELS` возвращают строку «Сетбол», «Матчбол» или «Таймаут».
   - `AUTO_EVENT_PRIORITY_ORDER` содержит 6 элементов и каждый из `AUTO_EVENT_TYPES`.
2. **Реализация:** Файл `src/shared/eventOverlayTypes.ts` с константами и типами.
3. Запуск тестов: `npm run test -- eventOverlayTypes`.

---

## Этап 1: Таймаут в приложении (состояние + useMatch)

**Цель:** Хранить состояние таймаута (какая команда, идёт/не идёт); переключать по кнопке (toggle).

**1.1. Где хранить состояние**

Таймаут хранить **только в состоянии useMatch**, без полей в `Match`. Не меняем структуру матча и JSON: при перезагрузке страницы таймаут сбрасывается. Состояние: `timeoutTeam: 'A' | 'B' | null`, `isTimeoutActive: boolean`.

**1.2. useMatch: состояние и API**

- Добавить в состояние: `timeoutTeam: 'A' | 'B' | null`, `isTimeoutActive: boolean`.
- Функция `toggleTimeout(team: 'A' | 'B')`: если таймаут не активен — включить для этой команды; если активен для этой команды — выключить; если активен для другой команды — переключить таймаут на нажатую команду.
- В return useMatch добавить: `timeoutTeam`, `isTimeoutActive`, `toggleTimeout`.

**1.3. TDD**

1. **Тесты** (`tests/unit/renderer/useMatch-timeout.test.ts` или расширить `useMatch.test.ts`):
   - Начальное состояние: таймаут не активен.
   - `toggleTimeout('A')` → таймаут активен, команда A.
   - Повторный `toggleTimeout('A')` → таймаут не активен.
   - `toggleTimeout('A')`, затем `toggleTimeout('B')` → таймаут активен для команды B.
2. Реализация в useMatch.
3. Запуск: `npm run test -- useMatch`.

---

## Этап 2: Карта данных «Автособытие» и контекст в getValueByDataMapKey

**Цель:** Поле «Автособытие» (ключ `event.autoLabel`) в карте данных; значение зависит от контекста `eventType`, а не от глобального текущего события.

**2.1. getValueByDataMapKey**

- Сигнатура: добавить опциональный третий аргумент `options?: { eventType?: string }`.
- Для ключа `event.autoLabel`: при наличии `options.eventType` возвращать значение из `AUTO_EVENT_LABELS[options.eventType]`, иначе возвращать пустую строку.
- Остальные ключи контекст не используют.

**2.2. dataMapCatalog**

- Добавить в группу «Счёт» один пункт: ключ `event.autoLabel`, подпись «Автособытие», тип `text`.

**2.3. TDD**

1. **Тесты** (`tests/unit/shared/getValueByDataMapKey.test.ts` — новый describe):
   - `getValueByDataMapKey(match, 'event.autoLabel', { eventType: 'setballA' })` → `'Сетбол'`.
   - `getValueByDataMapKey(match, 'event.autoLabel', { eventType: 'timeoutB' })` → `'Таймаут'`.
   - Для всех шести `eventType` — соответствующие метки.
   - Без контекста: `getValueByDataMapKey(match, 'event.autoLabel')` → `''`.
2. Реализация в getValueByDataMapKey и добавление ключа в dataMapCatalog.
3. Запуск: `npm run test -- getValueByDataMapKey`.

---

## Этап 3: Конфиг vMix и валидация настроек

**Цель:** В конфиге инпута поддерживать `isScoreInput`, `autoEvent`, `autoEventTypes`, `autoEventShowAlongside`; валидация: только один инпут со счётом; один тип события = один инпут.

**3.1. Структура конфига инпута (дополнительные поля)**

- `isScoreInput?: boolean` — использовать как инпут со счётом (только один true в конфиге).
- `autoEvent?: boolean` — инпут участвует в авто-показе по событиям.
- `autoEventTypes?: AutoEventType[]` — массив выбранных типов (например `['setballA', 'timeoutA']`).
- `autoEventShowAlongside?: boolean` — показывать совместно с другими событийными плашками (по умолчанию false).

**3.2. settingsValidator**

- В `validateVMixInput`: не требовать `enabled` если позже решим делать его опциональным для авто-инпутов; пока оставить как есть. Добавить проверку опциональных полей:
  - `isScoreInput` — если есть, то boolean.
  - `autoEvent` — если есть, то boolean.
  - `autoEventTypes` — если есть, то массив строк из набора AUTO_EVENT_TYPES.
  - `autoEventShowAlongside` — если есть, то boolean.
- В `validateVMixSettings`: если у нескольких инпутов `isScoreInput === true`, добавлять ошибку «Только один инпут может быть инпутом со счётом». При наличии `autoEvent` и `autoEventTypes`: для каждого типа события проверить, что он указан не более чем у одного инпута; иначе ошибка «Тип события X уже выбран у другого инпута».

**3.3. TDD**

1. **Тесты** (`tests/unit/main/settings-validator.test.ts` или отдельный файл для vmix):
   - Инпут с `isScoreInput: true` и `autoEvent: true` валиден (если остальное ок).
   - Два инпута с `isScoreInput: true` → ошибка.
   - Два инпута с `autoEventTypes`, оба содержат `setballA` → ошибка.
   - Один инпут с `autoEventTypes: ['setballA']`, другой с `['timeoutA']` → валидно.
2. Реализация в settingsValidator.
3. Запуск тестов валидатора.

---

## Этап 4: UI настроек vMix (галка счёт, авто-инпуты, галочки событий)

**Цель:** На странице «Настройки vMix» в панели редактирования инпута: галка «Использовать как инпут со счётом»; при включённом «Автоматический инпут по событиям» — галочки по 6 типам событий и флаг «Показывать совместно с другими»; правило один тип = один инпут.

**4.1. Галка «Использовать как инпут со счётом»**

- В блоке «Настройки инпута» (VMixSettingsPage) добавить чекбокс «Использовать как инпут со счётом», привязанный к `config.inputs[id].isScoreInput`.
- При установке галки в true для одного инпута — снять `isScoreInput` у всех остальных (проход по `config.inputOrder` / `config.inputs` и обнуление у других).

**4.2. Блок «Автоматический инпут по событиям»**

- Чекбокс «Автоматически показывать при событиях» → `autoEvent: true/false`.
- Если `autoEvent` true — показать:
  - Шесть чекбоксов: «Сетбол А», «Сетбол Б», «Матчбол А», «Матчбол Б», «Таймаут А», «Таймаут Б» (привязка к `autoEventTypes`).
  - Чекбокс «Показывать совместно с другими событийными плашками» → `autoEventShowAlongside`.
- Правило один тип = один инпут: при включении галочки типа события на текущем инпуте пройти по остальным инпутам и убрать этот тип из их `autoEventTypes`.

**4.3. Валидация при сохранении**

- Перед сохранением можно вызывать validateVMixSettings и показывать ошибки; либо полагаться на валидацию в main при setVMixConfig.

**4.4. TDD**

1. **Тесты** (компонент или страница):
   - Рендер галки «Использовать как инпут со счётом» и её переключение.
   - При включении «инпут со счётом» у одного инпута у другого снимается (проверка через setConfig или состояние).
   - Рендер блока авто-событий при `autoEvent: true`; шесть галочек и флаг «показывать совместно».
   - При выборе типа события у инпута A тот же тип снимается у инпута B (интеграционный или unit с моком config).
2. Реализация в VMixSettingsPage (и при необходимости в дочернем компоненте для блока авто-событий).
3. Запуск: `npm run test -- VMixSettingsPage`.

---

## Этап 5: Логика авто-показа и скрытия в useVMix

**Цель:** Определять активные события по матчу (сетбол, матчбол, таймаут) и приоритету; показывать/скрывать авто-инпуты в зависимости от оверлея со счётом; при обновлении полей авто-инпута передавать контекст `eventType` в getValueByDataMapKey.

**5.1. Входные данные**

- Из useMatch доступны: `isSetballNow`, `setballTeam`, `isMatchballNow`, `matchballTeam`, плюс после этапа 1 — `timeoutTeam`, `isTimeoutActive`.
- Конфиг vMix: для каждого инпута `overlay`, `autoEvent`, `autoEventTypes`, `autoEventShowAlongside`, `isScoreInput`.
- Состояние оверлеев (уже есть): какой инпут в каком оверлее показан.

**5.2. Алгоритм**

1. Найти инпут со счётом (`isScoreInput === true`). Если нет — авто-показ не выполнять.
2. По состоянию оверлеев определить, активен ли оверлей этого инпута (опрос уже даёт overlayStates). Если оверлей счёта не активен — все авто-инпуты скрыть (вызвать hideOverlay для каждого авто-инпута из конфига).
3. По матчу вычислить активные типы событий: setballA/setballB, matchballA/matchballB, timeoutA/timeoutB (по правилам и по timeoutTeam/isTimeoutActive).
4. Инпуты с `autoEventShowAlongside === false`: «основной слот» — выбрать одно событие по приоритету из активных; показать инпут, у которого в `autoEventTypes` есть это событие; обновить его поля с контекстом `eventType: выбранный_тип`.
5. Инпуты с `autoEventShowAlongside === true`: для каждого активного типа события показать инпут, у которого этот тип в `autoEventTypes`; обновить поля с контекстом `eventType`.
6. Инпуты, которые были показаны автоматически, но их событие перестало быть активным — скрыть (hideOverlay).

**5.3. Интеграция с updateSingleDynamicInput**

- При вызове `updateSingleDynamicInput` для авто-инпута передавать четвёртый аргумент (или опцию) `eventType`. Внутри при сборе полей для полей с `dataMapKey === 'event.autoLabel'` вызывать `getValueByDataMapKey(matchData, key, { eventType })`. Остальные поля — как раньше.
- Либо вынести сбор полей в функцию, принимающую `eventType?: string`, и в useVMix при обновлении авто-инпута передавать соответствующий eventType.

**5.4. Место вызова логики авто-показа**

- Либо в том же useVMix: при изменении match (или overlayStates) вызывать функцию «синхронизировать авто-оверлеи» (показать/скрыть нужные инпуты и обновить их поля).
- Логику авто-показа реализовать **внутри useVMix** (отдельный хук не заводить).

**5.5. TDD**

1. **Тесты** (например, `tests/unit/renderer/useVMix-auto-event-overlays.test.ts`):
   - При отсутствии инпута со счётом авто-показ не вызывается (мок getVMixConfig без isScoreInput).
   - При оверлее счёта неактивном — hideOverlay вызывается для всех авто-инпутов.
   - При активном сетболе А и одном авто-инпуте с типом setballA и режимом «замена» — вызывается showOverlay для этого инпута и update с eventType setballA.
   - При активном таймауте А и отдельном авто-инпуте с типом timeoutA и «показывать совместно» — показываются оба инпута (сетбол и таймаут), если оба в конфиге.
2. Реализация в useVMix (вынести хелперы в чистые функции при необходимости для тестов).
3. Запуск тестов useVMix.

---

## Этап 6: Скрытие авто-инпутов при выключении счёта в приложении

**Цель:** При нажатии пользователем кнопки «выключить счёт» (hideOverlay для инпута со счётом) дополнительно скрыть все автоматические инпуты.

**6.1. Реализация**

В useVMix обернуть вызов hideOverlay: если передан inputKey инпута со счётом (`isScoreInput`), сначала вызвать hideOverlay для каждого авто-инпута (по config.inputOrder и config.inputs с `autoEvent === true`), затем hideOverlay для счётного инпута. MatchControlPage по-прежнему вызывает один hideOverlay(inputKey).

**6.2. TDD**

- Тест: при вызове hideOverlay с ключом инпута со счётом в моках зафиксировать, что вызваны hideOverlay для счётного инпута и для всех авто-инпутов.
- Реализация.

---

## Этап 7: Страница «Управление матчем» — таймауты и пометка авто-инпутов

**Цель:** Кнопки «Таймаут А» и «Таймаут Б» (toggle); в блоке «Управление плашками vMix» помечать авто-инпуты и допускать ручной показ.

**7.1. Кнопки таймаута**

- Разместить блок «Таймауты» с двумя кнопками «Таймаут А» и «Таймаут Б» под блоком «Управление плашками vMix». По нажатию вызывать `toggleTimeout('A')` / `toggleTimeout('B')` из useMatch.
- Активный таймаут подсвечивать цветом кнопки (выделенная кнопка для команды, у которой таймаут идёт).

**7.2. Пометка авто-инпутов в VMixOverlayButtons**

- В списке кнопок плашек для инпутов с `autoEvent === true` показывать пометку «автоматический» (подпись или бейдж). Ручное включение/выключение оставить как есть (допускается).

**7.3. TDD**

- Тесты MatchControlPage: наличие кнопок «Таймаут А»/«Таймаут Б» и вызов toggleTimeout при клике.
- Тесты VMixOverlayButtons: для инпута с autoEvent отображается пометка «автоматический».

---

## Чек-лист тестов по этапам

| Этап | Файлы тестов | Что покрыть |
|------|--------------|-------------|
| 0 | eventOverlayTypes.test.ts | Константы и метки |
| 1 | useMatch-timeout.test.ts | toggleTimeout, состояние таймаута |
| 2 | getValueByDataMapKey.test.ts | event.autoLabel с контекстом eventType |
| 3 | settings-validator.test.ts | isScoreInput единственный, один тип = один инпут |
| 4 | VMixSettingsPage.test.tsx | Галка счёт, блок авто-событий, снятие типа с другого инпута |
| 5 | useVMix-auto-event-overlays.test.ts | Показ/скрытие по оверлею счёта и событиям, контекст eventType при обновлении |
| 6 | useVMix или main | hideOverlay счёта → hide всех авто |
| 7 | MatchControlPage.test.tsx, VMixOverlayButtons.test.tsx | Кнопки таймаута, пометка «автоматический» |

После каждого этапа: `npm run test` и при необходимости `npm run test:coverage` (держать пороги по правилам проекта).

---

## Обратная совместимость

- Конфиги без `isScoreInput` и `autoEvent`: авто-логика не срабатывает (нет инпута со счётом → не показываем авто; нет авто-инпутов — нечего показывать). Валидатор не требовать эти поля.
- Старые вызовы `getValueByDataMapKey(match, key)` без третьего аргумента — работают как раньше; для `event.autoLabel` без контекста возвращать пустую строку.

---

## Порядок выполнения (сводка)

1. **Этап 0** — константы и типы событий.
2. **Этап 1** — таймаут в useMatch (state + toggle).
3. **Этап 2** — «Автособытие» в карте данных и контекст в getValueByDataMapKey.
4. **Этап 3** — валидация конфига (isScoreInput, autoEvent, один тип = один инпут).
5. **Этап 4** — UI настроек vMix (галки и блок авто-событий).
6. **Этап 5** — логика авто-показа/скрытия и обновление полей с eventType в useVMix.
7. **Этап 6** — при выключении счёта скрывать все авто-инпуты.
8. **Этап 7** — кнопки «Таймаут А»/«Таймаут Б» на странице матча и пометка авто-инпутов в плашках.

По завершении обновить документацию (архитектура, справочник API, при необходимости vmix-event-overlays-setball-matchball-timeout.md).
