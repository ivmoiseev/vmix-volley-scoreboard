# Инструкции по реализации рефакторинга: работа с инпутами vMix

*Последнее обновление: 2026-02-03*

## 1. Назначение документа

Документ содержит **пошаговые инструкции для программистов** по выполнению рефакторинга работы с инпутами vMix. Рефакторинг выполняется **через TDD** (Test-Driven Development): сначала тесты, затем минимальная реализация, затем рефакторинг.

**Базовый документ:** [План рефакторинга: работа с инпутами vMix (динамическая настройка)](vmix-inputs-refactoring-plan.md). Все требования, структура данных и сценарии описаны в плане; в этом документе — разбивка на этапы, порядок работ и конкретные шаги TDD.

---

## 2. Общие принципы TDD в рамках рефакторинга

### 2.1. Цикл Red — Green — Refactor

1. **Red:** Написать тест, который описывает желаемое поведение. Запустить тесты — новый тест падает.
2. **Green:** Написать минимальный код, чтобы тест прошёл. Не усложнять; дублирование допустимо на этом шаге.
3. **Refactor:** Улучшить код, сохраняя зелёные тесты. Убрать дублирование, улучшить читаемость.

### 2.2. Рекомендации

- Один тест — один аспект поведения (один `expect` или логически связанная группа).
- Имена тестов — на русском или английском, формулировка в духе «должен …», «при … возвращает …».
- Перед началом этапа убедиться, что все существующие тесты проходят: `npm test`.
- После каждого этапа запускать полный набор тестов: `npm test`, при необходимости `npm run test:coverage` (порог покрытия по правилам проекта).
- Использовать **режим watch** во время разработки: `npm run test:watch`.

### 2.3. Структура тестов проекта

- **Юнит-тесты:** `tests/unit/` — по модулям (main, renderer, shared). Подпапки повторяют структуру `src/`.
- **Интеграционные тесты:** `tests/integration/`.
- **Настройка окружения:** `tests/setup.js`.
- **Запуск:** `npm test`, `npm run test:unit`, `npm run test:integration`, `npm run test:watch`.

---

## 3. Подготовка к рефакторингу

### 3.1. Ветка и окружение

1. Создать отдельную ветку для рефакторинга (например, `feature/vmix-inputs-refactoring`).
2. Убедиться, что в `main` все тесты зелёные: `npm test`.
3. Документация под рукой: план рефакторинга, vmix-data-map.md, vmix-api-response.xml.

### 3.2. Порядок этапов (зависимости)

Этапы рекомендуется выполнять в указанном порядке: последующие опираются на предыдущие.

| Этап | Название | Зависимости |
|------|----------|--------------|
| **Этап 1** | Подключение к vMix (connectionState, Подключить/Отключить) | — |
| **Этап 2** | API Main Process (getGTInputs, getInputFields, кэш, IPC) | — |
| **Этап 3** | Структура данных настроек (inputOrder, пустой inputs, валидация) | Этап 1 (частично) |
| **Этап 4** | Справочник данных приложения (иерархия, фильтр по типу) | — |
| **Этап 5** | UI: страница «Настройки vMix» (список инпутов, добавление, удаление, порядок) | Этапы 1, 2, 3 |
| **Этап 6** | UI: поля инпута (раскрывающиеся блоки, сопоставление, customValue) | Этапы 2, 3, 4, 5 |
| **Этап 7** | Логика отправки в vMix (useVMix по новой структуре, Input=vmixTitle) | Этапы 2, 3, 4 |
| **Этап 8** | Компонент «Управление плашками vMix» на странице «Управление матчем» | Этапы 3, 5 |
| **Этап 9** | Интеграционное тестирование и документация | Все предыдущие |

---

## 4. Этап 1: Подключение к vMix (connectionState, Подключить/Отключить)

**Цель:** Сохранять и восстанавливать состояние подключения; при «Подключить» сохранять `connectionState: "connected"` в файл; при «Отключить» — `"disconnected"`; при запуске приложения при `connectionState === "connected"` автоматически выполнять подключение.

**Ссылка на план:** раздел 1, раздел 5 (структура vmix), раздел 8 (решение по сохранению connectionState).

### 4.1. Red: тесты

1. **settingsManager / чтение и запись connectionState**
   - Файл: `tests/unit/main/settingsManager-vmix-connection.test.ts` (или добавить в существующий тест настроек).
   - Тесты:
     - При загрузке настроек секция `vmix` содержит `connectionState` (если есть в файле).
     - При сохранении vmix-настроек с `connectionState: "connected"` значение записывается в файл.
     - При сохранении vmix-настроек с `connectionState: "disconnected"` значение записывается в файл.
   - При отсутствии в файле `vmix.connectionState` — использовать значение по умолчанию (например, `"disconnected"`).

2. **IPC / сохранение connectionState при подключении и отключении**
   - Файл: `tests/unit/main/vmix-connection-ipc.test.ts` или интеграционный тест.
   - Тесты (с моками settingsManager):
     - Обработчик подключения (например, `vmix:connect`) вызывает сохранение настроек с `connectionState: "connected"` и записывает в файл (или через settingsManager).
     - Обработчик отключения (`vmix:disconnect`) сохраняет `connectionState: "disconnected"` в файл.

3. **Валидация настроек**
   - Файл: `tests/unit/main/utils/settings-validator.test.ts` (расширить).
   - Тест: валидатор допускает `vmix.connectionState` со значениями `"connected"` и `"disconnected"` (и при необходимости отбрасывает неизвестные значения).

### 4.2. Green: реализация

1. **settingsManager.ts**
   - В тип/интерфейс секции `vmix` добавить поле `connectionState?: 'connected' | 'disconnected'`.
   - В `getDefaultSettings()` (или аналог) для vmix задать `connectionState: 'disconnected'` по умолчанию.
   - При сохранении vmix-настроек записывать `connectionState` в файл (уже входит в объект vmix при `setVMixConfig` или аналоге).
   - Убедиться, что при загрузке приложения вызывается загрузка настроек и при `connectionState === 'connected'` выполняется запрос к vMix API (см. main.ts и/или vmix-config).

2. **main.ts (или отдельный модуль IPC для vMix)**
   - Добавить обработчик подключения: по запросу от renderer выполнить запрос к `http://{host}:{port}/api`; при успехе вызвать сохранение настроек с `host`, `port`, `connectionState: 'connected'` и **записать в файл сразу** (не ждать «Сохранить»).
   - Добавить обработчик отключения: сохранить в настройки `connectionState: 'disconnected'` и **записать в файл сразу**.
   - Зарегистрировать вызовы в preload (например, `vmix:connect`, `vmix:disconnect`).

3. **settingsValidator.ts**
   - В схему валидации секции `vmix` добавить проверку `connectionState`: допустимые значения `'connected'`, `'disconnected'` (или отсутствие поля).

4. **Восстановление при запуске**
   - В точке инициализации приложения (main): после загрузки настроек проверить `vmix.connectionState === 'connected'`; если да — установить соединение с vMix (host/port из настроек), например вызвать тест подключения или инициализировать vmix-client.

### 4.3. Refactor

- Вынести логику «сохранить connectionState в файл» в одну функцию (если дублируется).
- Убедиться, что индикатор подключения на других страницах не меняется (оставить только там, где уже есть).

### 4.4. Файлы для создания/изменения

| Действие | Файл |
|----------|------|
| Изменить | `src/main/settingsManager.ts` |
| Изменить | `src/main/utils/settingsValidator.ts` |
| Изменить | `src/main/main.ts` (или модуль IPC vmix) |
| Изменить | `src/main/preload.cjs` (expose vmix:connect, vmix:disconnect) |
| Создать/изменить | `tests/unit/main/settingsManager-vmix-connection.test.ts` (или в существующем тесте настроек) |
| Создать/изменить | `tests/unit/main/utils/settings-validator.test.ts` |

---

## 5. Этап 2: API Main Process (getGTInputs, getInputFields, кэш, IPC)

**Цель:** В `vmix-client.ts` добавить метод `getGTInputs()` (парсинг XML, фильтр по `type="GT"`), метод `getInputFields(inputNumber)` (или по ключу), кэш списка полей по инпуту; зарегистрировать IPC `vmix:getGTInputs`, `vmix:getInputFields`.

**Ссылка на план:** раздел 2, этап 2 в разделе 6 плана.

### 5.1. Red: тесты

1. **vmix-client: getGTInputs**
   - Файл: `tests/unit/main/vmix-client-getGTInputs.test.ts`.
   - Мокать HTTP-запрос к `/api` (axios или сетевая заглушка), подставлять XML из `docs/api/vmix-api-response.xml` (или укороченный фрагмент с несколькими инпутами, в т.ч. type="GT" и не GT).
   - Тесты:
     - Возвращает только инпуты с `type="GT"`.
     - Каждый элемент содержит `number`, `key`, `title`, `shortTitle`.
     - Инпуты с типами NDI, Colour и т.д. не попадают в результат.
   - При ошибке сети/парсинга — возвращать `{ success: false, error: string, inputs: [] }`.

2. **vmix-client: getInputFields**
   - Файл: `tests/unit/main/vmix-client-getInputFields.test.ts`.
   - Мокать ответ API с фрагментом XML одного инпута (теги `<text>`, `<color>`, `<image>` с атрибутами `name`, `index`).
   - Тесты:
     - Возвращает массив полей с полями `type` ('text' | 'color' | 'image'), `name`, `index`.
     - Порядок соответствует порядку в XML (или явно задан в тесте).
   - Вызов для несуществующего номера инпута — пустой массив или ошибка (зафиксировать в тесте).

3. **vmix-client: кэш полей**
   - В том же или отдельном тесте:
     - После успешного `getInputFields(inputId)` повторный вызов с тем же `inputId` возвращает данные из кэша (можно проверить через мок: HTTP вызывается один раз, второй вызов — без запроса, если кэш реализован в клиенте).
   - Опционально: тест инвалидации кэша (если будет требование сбрасывать кэш при отключении).

### 5.2. Green: реализация

1. **vmix-client.ts**
   - Реализовать `getGTInputs()`: GET `${this.baseURL}` (или `/api`), парсинг XML (xml2js), обход `result.vmix.inputs.input`, фильтр по `input.$.type === 'GT'`, формирование массива `{ number, key, title, shortTitle }`.
   - Реализовать `getInputFields(inputNumber)`: использовать полный ответ API (можно вызывать GET `/api` и искать инпут по number в разобранном XML) или отдельный запрос; извлечь дочерние элементы input — теги `text`, `color`, `image`; для каждого вернуть `{ type, name: attr.name, index: attr.index }`.
   - Добавить кэш: объект `Map` или обычный объект `fieldsCacheByInputKey` / `fieldsCacheByInputNumber`; ключ — номер инпута (или vmixTitle); после успешного `getInputFields` сохранять результат в кэш; при вызове `getInputFields` сначала проверять кэш, при попадании — возвращать из кэша без запроса (при необходимости добавить параметр `forceRefresh`).

2. **main.ts (IPC)**
   - `ipcMain.handle('vmix:getGTInputs', async () => { ... getVMixClient(...).getGTInputs() ... })`.
   - `ipcMain.handle('vmix:getInputFields', async (e, inputNumberOrKey) => { ... getInputFields(inputNumberOrKey) ... })`.
   - В preload: `getGTInputs: () => ipcRenderer.invoke('vmix:getGTInputs')`, `getInputFields: (inputNumberOrKey) => ipcRenderer.invoke('vmix:getInputFields', inputNumberOrKey)`.

### 5.3. Refactor

- Вынести парсинг XML в приватные методы или утилиты, если дублируется.
- Убедиться, что имена полей с точками и спецсимволами корректно возвращаются (без потерь).

### 5.4. Файлы для создания/изменения

| Действие | Файл |
|----------|------|
| Изменить | `src/main/vmix-client.ts` |
| Изменить | `src/main/main.ts` |
| Изменить | `src/main/preload.cjs` |
| Создать | `tests/unit/main/vmix-client-getGTInputs.test.ts` |
| Создать | `tests/unit/main/vmix-client-getInputFields.test.ts` |

---

## 6. Этап 3: Структура данных настроек (inputOrder, пустой inputs, валидация)

**Цель:** Секция `vmix` в настройках поддерживает `inputOrder: string[]`, `inputs: Record<string, VMixInputConfig}`; при отсутствии — по умолчанию `inputOrder: []`, `inputs: {}`. Валидация допускает новую структуру; при удалении инпута id убирается из `inputOrder`.

**Ссылка на план:** раздел 5 плана, этап 7 (миграция не требуется).

### 6.1. Red: тесты

1. **settingsManager: vmix.inputOrder и vmix.inputs**
   - Файл: `tests/unit/main/settingsManager-vmix-structure.test.ts` (или расширить существующий).
   - Тесты:
     - По умолчанию (новые настройки) `vmix.inputOrder` — пустой массив, `vmix.inputs` — пустой объект.
     - При загрузке из файла с `vmix.inputOrder` и `vmix.inputs` значения загружаются без потерь.
     - При сохранении vmix-настроек с `inputOrder` и `inputs` они записываются в файл.
   - Структура одного инпута: `displayName`, `vmixTitle`, `vmixKey`, `vmixNumber`, `enabled`, `overlay`, `fields` (объект, ключи — имена полей vMix).

2. **Валидация**
   - В `settings-validator.test.ts`: секция `vmix` может содержать `inputOrder` (массив строк), `inputs` (объект); валидатор не падает и не удаляет эти поля при валидных данных.

3. **Удаление инпута из inputOrder**
   - Тест (в логике или в UI-слое): при удалении инпута с id `input_1` из `config.inputs` массив `inputOrder` обновляется — id `input_1` удаляется. Можно тестировать в модуле, который выполняет «удалить инпут» (например, функция `removeInputFromConfig(config, inputId)` в shared или main).

### 6.2. Green: реализация

1. **settingsManager.ts**
   - В дефолтных настройках vmix задать `inputOrder: []`, `inputs: {}`.
   - При чтении/записи не удалять и не перезаписывать `inputOrder` и `inputs` произвольно; при миграции со старого формата (если в плане решено не мигрировать) — для новой версии просто считать, что при отсутствии ключей это пустой массив/объект.

2. **settingsValidator.ts**
   - Разрешить в `vmix` поля `inputOrder` (массив строк), `inputs` (объект). Опционально: проверка структуры каждого элемента `inputs` (displayName, vmixTitle, fields и т.д.).

3. **Утилита или логика удаления инпута**
   - Функция вида `removeInputFromVMixConfig(config, inputId)`: удалить `config.vmix.inputs[inputId]`, удалить `inputId` из `config.vmix.inputOrder`. Вызывать при удалении инпута (в main при обработке IPC или в renderer перед отправкой сохранения).

### 6.3. Refactor

- Общие типы для VMixInputConfig, VMixFieldConfig вынести в shared/types (например, расширить существующий файл типов настроек).

### 6.4. Файлы для создания/изменения

| Действие | Файл |
|----------|------|
| Изменить | `src/main/settingsManager.ts` |
| Изменить | `src/main/utils/settingsValidator.ts` |
| Создать/изменить | `src/shared/types/` (типы VMixInputConfig, VMixFieldConfig при необходимости) |
| Создать/изменить | `tests/unit/main/settingsManager-vmix-structure.test.ts` |
| Создать | `tests/unit/shared/vmix-config-utils.test.ts` (для removeInputFromVMixConfig и т.п., если вынесено в shared) |

---

## 7. Этап 4: Справочник данных приложения (иерархия, фильтр по типу)

**Цель:** На основе vmix-data-map сформировать иерархический справочник пунктов «Данные приложения» с человекопонятными названиями; модель данных — расширяемая; функция фильтрации по типу поля (text / color / image).

**Ссылка на план:** раздел 4.3 плана, этап 6 плана.

### 7.1. Red: тесты

1. **Модуль справочника (dataMapCatalog или аналог)**
   - Файл: `tests/unit/shared/dataMapCatalog.test.ts` (или renderer, если справочник живёт в renderer).
   - Тесты:
     - `getDataMapCatalog()` возвращает иерархическую структуру (группы: «Турнир», «Команды», «Счёт», «Судьи» и т.д.); каждая группа содержит массив пунктов с `key` и `label` (человекопонятное название).
     - `getDataMapCatalog({ fieldType: 'text' })` возвращает только пункты, подходящие для типа text (все или только с типом text, в зависимости от модели).
     - `getDataMapCatalog({ fieldType: 'color' })` возвращает только пункты типа color (цвета).
     - `getDataMapCatalog({ fieldType: 'image' })` возвращает только пункты типа image (логотипы и т.д.).
   - Пункты видимости (индикатор подачи A/B) — в справочнике как отдельные «виртуальные» пункты с пометкой типа (visibility или специальный ключ).

2. **Структура пункта**
   - Каждый пункт: `{ key: string, label: string, type?: 'text' | 'color' | 'image' | 'visibility' }` (или вложенная структура по группам). Ключ однозначно определяет источник данных в match (например, `teamA.name`, `currentSet.scoreA`).

### 7.2. Green: реализация

1. **Создать модуль справочника**
   - Файл: `src/shared/dataMapCatalog.js` (или `.ts`). Либо `src/renderer/utils/dataMapCatalog.js`, если используется только в renderer.
   - Константа или функция, возвращающая иерархический список: массив групп `{ id, label, items: [{ key, label, type }] }`. Данные взять из vmix-data-map.md (разделы 1–12).
   - Функция `getDataMapCatalog(options?: { fieldType?: 'text' | 'color' | 'image' })`: при указании `fieldType` отфильтровать пункты по типу; для text показывать все текстовые + виртуальные (visibility); для color — только color; для image — только image.
   - Модель сделать расширяемой: добавление новой группы или пункта — через добавление элемента в массив/объект без изменения сигнатур.

### 7.3. Refactor

- Вынести константы групп и ключей в отдельный файл, если список большой.
- Проверить, что все ключи из vmix-data-map покрыты (сверить с разделами документа).

### 7.4. Файлы для создания/изменения

| Действие | Файл |
|----------|------|
| Создать | `src/shared/dataMapCatalog.js` (или renderer/utils) |
| Создать | `tests/unit/shared/dataMapCatalog.test.ts` |

---

## 8. Этап 5: UI — страница «Настройки vMix» (список инпутов, добавление, удаление, порядок)

**Цель:** На странице «Настройки подключения к vMix» блок «Настройка инпутов» по умолчанию пустой; кнопка «Добавить инпут»; модальное окно (название + выпадающий список GT-инпутов); при создании инпута присваивать uuid; список инпутов в порядке `inputOrder`; перетаскивание по вертикали; удаление инпута (с подтверждением, с удалением id из `inputOrder`); недоступные инпуты помечаются визуально.

**Ссылка на план:** разделы 3.2–3.6, 3.7, этап 3 плана.

### 8.1. Red: тесты

1. **Компонент VMixSettingsPage (или подкомпоненты)**
   - Файл: `tests/unit/renderer/VMixSettingsPage-inputs.test.jsx` (или расширить существующий тест страницы).
   - Тесты (с моками IPC и настроек):
     - При пустом `config.inputs` и пустом `inputOrder` в левой колонке отображается пустой список (или заглушка «Нет инпутов»).
     - Кнопка «Добавить инпут» присутствует и при клике открывает модальное окно (или показывается форма добавления).
     - При наличии инпутов в `config.inputs` они отображаются в порядке `inputOrder`.
     - В модальном окне «Добавить инпут» есть поле ввода названия и выпадающий список (опции GT-инпутов подставляются из мока `getGTInputs`).
   - Удаление: кнопка «Удалить инпут» при клике показывает подтверждение (или вызывает callback удаления с правильным id); после подтверждения из конфига удаляется инпут и его id из `inputOrder` (проверять через передачу обновлённого config в мок сохранения).

2. **Генерация uuid для нового инпута**
   - В тесте добавления инпута: при подтверждении модального окна в сохранённый объект инпута входит ключ (id), который является непустой строкой и не совпадает с displayName (т.е. это uuid или аналог). Можно мокать `crypto.randomUUID` или аналог.

3. **Недоступные инпуты**
   - Компонент списка инпутов получает признак «недоступен» для каждого инпута (например, проп `unavailableInputIds` или флаг в объекте инпута). Для недоступного инпута рендерится класс/стиль «недоступен» или подпись «Недоступен» (проверка по data-testid или тексту).

### 8.2. Green: реализация

1. **VMixSettingsPage.jsx**
   - Загружать настройки vmix; при отсутствии `inputOrder` использовать `[]`, при отсутствии `inputs` использовать `{}`.
   - Левая колонка: отображать инпуты в порядке `config.vmix.inputOrder` (или `inputOrder` из состояния); для каждого id брать `config.vmix.inputs[id]`; отображать `displayName`; чекбокс enabled, при клике на строку — выбор инпута.
   - Сверху блока «Настройка инпутов» — кнопка «Добавить инпут»; по клику открывать модальное окно (состояние `showAddInputModal`).
   - Модальное окно: поле ввода «Название» (displayName), выпадающий список «Инпут vMix» — опции из `getGTInputs()` (при открытии модального окна вызвать IPC); кнопки «Отмена» и «Добавить». При «Добавить»: сгенерировать uuid (например, `crypto.randomUUID()`), создать объект инпута `{ displayName, vmixTitle, vmixKey, vmixNumber, enabled: true, overlay: 1, fields: {} }`, добавить в `config.vmix.inputs[uuid]`, добавить uuid в конец `config.vmix.inputOrder`, закрыть модальное окно. Сохранение в файл — только при нажатии «Сохранить» (не в момент добавления).
   - Правая панель: для выбранного инпута — отображаемое имя, включить/выключить, номер оверлея, кнопка «Удалить инпут». При «Удалить инпут» — показать `confirm`; при подтверждении удалить инпут из `inputs`, удалить id из `inputOrder`, сбросить выбранный инпут (например, на следующий в списке).
   - Перетаскивание: подключить библиотеку (например, react-beautiful-dnd или @dnd-kit) для списка инпутов в левой колонке; при изменении порядка обновлять `inputOrder` в состоянии (в файл — по «Сохранить»).
   - Недоступные инпуты: вычислить список недоступных (например, по ответу getGTInputs — какие vmixTitle есть в vMix; инпуты, у которых vmixTitle нет в списке, или при отсутствии связи — все помечать как недоступные). Для недоступных применять стиль (серый, иконка) и подпись «Недоступен» или «Инпут не найден в vMix».

2. **Preload**
   - Убедиться, что `getGTInputs`, `getInputFields` доступны из renderer.

### 8.3. Refactor

- Вынести модальное окно «Добавить инпут» в отдельный компонент.
- Вынести список инпутов (левая колонка) в компонент с пропсами (inputs, inputOrder, selectedId, onSelect, onReorder, onDelete, unavailableIds).

### 8.4. Файлы для создания/изменения

| Действие | Файл |
|----------|------|
| Изменить | `src/renderer/pages/VMixSettingsPage.jsx` |
| Создать | `src/renderer/components/AddVMixInputModal.jsx` (опционально) |
| Создать | `src/renderer/components/VMixInputsList.jsx` (опционально) |
| Создать/изменить | `tests/unit/renderer/VMixSettingsPage-inputs.test.jsx` |

---

## 9. Этап 6: UI — поля инпута (раскрывающиеся блоки, сопоставление, customValue)

**Цель:** При выборе инпута справа отображать все поля инпута из `getInputFields` (или из кэша) в виде раскрывающихся блоков; в блоке — выбор источника данных (справочник или «Произвольный текст» для text); ключ записи в fields — имя поля vMix; кнопка «Очистить сопоставление»; для недоступного инпута — только просмотр из кэша.

**Ссылка на план:** разделы 4.2–4.4, этап 4 плана.

### 9.1. Red: тесты

1. **Компонент списка полей (раскрывающиеся блоки)**
   - Файл: `tests/unit/renderer/VMixInputFieldsPanel.test.jsx` (или в составе VMixSettingsPage).
   - Тесты (моки getInputFields, справочника):
     - При выборе инпута отображается список блоков; заголовок каждого блока — имя поля vMix (name из getInputFields).
     - При наличии в `config.inputs[id].fields` записи с ключом, равным имени поля vMix, в заголовке блока отображается индикатор «сопоставлено» или превью (dataMapKey/customValue).
     - Раскрытие блока по клику: внутри отображаются выпадающий список «Данные приложения» (для text) и опция «Произвольный текст» с текстовым полем; для поля типа color/image — только выпадающий список, отфильтрованный по типу.
     - При выборе пункта из справочника в конфиг (в памяти) записывается поле с ключом = имя поля vMix, значением dataMapKey; при вводе произвольного текста и включённой галочке — customValue.
     - Кнопка «Очистить сопоставление» удаляет запись поля из `fields` выбранного инпута.
   - Режим только просмотр: при передаче пропа `readOnly` или `unavailable` блоки не содержат интерактивных элементов (выпадающий список и поле ввода disabled или скрыты).

2. **Кодировка имени поля**
   - В тесте сохранения поля с именем, содержащим точку (например, `Name_Team1.Text`): в конфиге ключ сохраняется как строка с точкой; при формировании запроса к vMix (в следующем этапе) SelectedName кодируется через encodeURIComponent.

### 9.2. Green: реализация

1. **Панель полей инпута**
   - Компонент (например, `VMixInputFieldsPanel.jsx`): принимает `inputId`, `config` (или `fields` и `onFieldChange`), `readOnly` (для недоступного инпута).
   - При монтировании/смене inputId вызывать `getInputFields(vmixNumber или vmixTitle)` (или брать из кэша); отображать список полей в виде аккордеона (раскрывающиеся блоки). Заголовок блока — `field.name`; в заголовке показывать превью: если в `config.inputs[inputId].fields[field.name]` есть запись — «сопоставлено» + label из справочника или customValue.
   - Внутри блока: для типа text — выпадающий список из `getDataMapCatalog({ fieldType: 'text' })` и галочка «Произвольный текст» + input; при галочке скрывать выпадающий список. Для color/image — выпадающий список из `getDataMapCatalog({ fieldType: 'color' })` или `'image'`. При выборе/вводе вызывать `onFieldChange(inputId, fieldName, { dataMapKey } | { customValue })` и обновлять локальное состояние или конфиг в родителе.
   - Кнопка «Очистить сопоставление»: удалить `config.inputs[inputId].fields[fieldName]` (ключ = имя поля vMix).
   - При `readOnly` не вызывать getInputFields по сети, брать из кэша; все контролы в блоках сделать disabled или только отображение.

2. **Интеграция в VMixSettingsPage**
   - Справа от списка инпутов рендерить `VMixInputFieldsPanel` с выбранным inputId, текущим config, и readOnly если инпут недоступный.

### 9.3. Refactor

- Вынести один «блок поля» в компонент `VMixFieldBlock.jsx`.
- Убедиться, что ключ в `fields` всегда совпадает с `field.name` из API (без лишних преобразований).

### 9.4. Файлы для создания/изменения

| Действие | Файл |
|----------|------|
| Создать | `src/renderer/components/VMixInputFieldsPanel.jsx` |
| Создать | `src/renderer/components/VMixFieldBlock.jsx` (опционально) |
| Изменить | `src/renderer/pages/VMixSettingsPage.jsx` |
| Создать | `tests/unit/renderer/VMixInputFieldsPanel.test.jsx` |

---

## 10. Этап 7: Логика отправки в vMix (useVMix по новой структуре, Input=vmixTitle)

**Цель:** Адаптировать useVMix (и при необходимости main): при обновлении матча проходить по сохранённым инпутам из `config.vmix.inputOrder` и `config.vmix.inputs`; для каждого инпута передавать в API параметр `Input=vmixTitle` (URL-кодированный); для каждого поля — значение из match по dataMapKey или customValue; вызывать SetText/SetColor/SetImage/SetTextVisibleOn/Off с `SelectedName` = имя поля vMix (ключ в fields), при необходимости кодировать для URL.

**Ссылка на план:** разделы 3.4, 4.2–4.4, этап 5 плана.

### 10.1. Red: тесты

1. **useVMix: отправка по новой структуре**
   - Файл: `tests/unit/renderer/useVMix-dynamic-inputs.test.js` (или расширить useVMix-field-types.test.js).
   - Мокать vmix-client.sendCommand (или IPC вызовы к main).
   - Тесты:
     - При вызове updateMatchData с конфигом, содержащим один инпут с `vmixTitle: "SCORE"` и полем с ключом `Name_Team1.Text` и `dataMapKey: "teamA.name"`, отправляется запрос SetText с параметрами `Input=SCORE` (или URL-кодированный), `SelectedName=Name_Team1.Text` (или кодированный), `Value=<значение match.teamA.name>`.
     - Для поля с `customValue: "Тренер команды"` отправляется SetText с `Value=Тренер команды` (без подстановки из match).
     - Инпуты с `enabled: false` пропускаются.
     - Поля с отсутствующим dataMapKey/customValue не отправляются (или отправляются пустой строкой — зафиксировать в тесте).
     - Для поля типа color вызывается SetColor с соответствующими параметрами; для image — SetImage.
     - Для «виртуальных» пунктов видимости (индикатор подачи) вызывается SetTextVisibleOn или SetTextVisibleOff в зависимости от значения из match.
   - Недоступные инпуты (например, vmixTitle не найден в текущем vMix) пропускаются при отправке.

2. **Кодирование URL**
   - Параметр Input в запросе к vMix должен быть URL-кодирован (например, пробел в title → %20). Тест: vmixTitle с пробелом передаётся в sendCommand как строка с encodeURIComponent.

### 10.2. Green: реализация

1. **useVMix.js**
   - В логике обновления инпутов (цикл по инпутам) брать список инпутов из `config.vmix.inputOrder` и для каждого id — `config.vmix.inputs[id]`. Пропускать инпуты с `enabled: false`. Проверять «доступность» инпута (если реализована проверка по списку GT из vMix — пропускать недоступные).
   - Для каждого инпута параметр `Input` в запросах к API задавать как `encodeURIComponent(config.vmix.inputs[id].vmixTitle)`.
   - Для каждого поля в `config.vmix.inputs[id].fields`: ключ — имя поля vMix; значение для отправки: если есть `customValue` — использовать его, иначе получить значение из `match` по `dataMapKey` (через существующие или новые функции форматирования). Вызывать sendCommand('SetText', …) или SetColor, SetImage, SetTextVisibleOn/Off в зависимости от типа поля и типа источника данных.
   - SelectedName в запросах — имя поля vMix (ключ в fields); при необходимости `encodeURIComponent`.

2. **vmix-client.ts (main)**
   - Убедиться, что sendCommand передаёт параметры в URL (Input, SelectedName, Value) с корректным кодированием (например, через URLSearchParams или encodeURIComponent для значений).

### 10.3. Refactor

- Вынести функцию «получить значение для поля по dataMapKey из match» в отдельный модуль (например, getValueByDataMapKey(match, dataMapKey)) и покрыть тестами.
- Общая логика «обход инпутов и полей конфига» — в одну функцию, чтобы useVMix оставался читаемым.

### 10.4. Файлы для создания/изменения

| Действие | Файл |
|----------|------|
| Изменить | `src/renderer/hooks/useVMix.js` |
| Изменить | `src/main/vmix-client.ts` (при необходимости кодирование) |
| Создать | `src/shared/getValueByDataMapKey.js` (опционально) |
| Создать/изменить | `tests/unit/renderer/useVMix-dynamic-inputs.test.js` |
| Создать | `tests/unit/shared/getValueByDataMapKey.test.js` (если вынесена функция) |

---

## 11. Этап 8: Компонент «Управление плашками vMix» на странице «Управление матчем»

**Цель:** Список инпутов в компоненте «Управление плашками vMix» — тот же, что на странице «Настройки vMix»: те же данные из `config.vmix.inputs` и порядок `inputOrder`; недоступные инпуты подсвечиваются так же, как сейчас.

**Ссылка на план:** раздел 3.7, этап 3 плана.

### 11.1. Red: тесты

1. **Компонент управления плашками**
   - Файл: `tests/unit/renderer/VMixOverlayButtons.test.jsx` (или аналог по имени компонента).
   - Тесты:
     - Компонент получает список инпутов в порядке `inputOrder` (проп или из контекста/настроек).
     - Отображаются кнопки/элементы для каждого инпута с отображаемым именем (`displayName`).
     - Для инпута с признаком «недоступен» применяется стиль/подпись как в текущей реализации (проверка по классу или тексту).

### 11.2. Green: реализация

1. **Компонент «Управление плашками vMix»**
   - Источник данных: те же настройки vmix (`config.vmix.inputOrder`, `config.vmix.inputs`). Получать их через существующий механизм (например, контекст настроек или хук useSettings).
   - Отрисовка списка: по `inputOrder` обходить и для каждого id рендерить элемент управления плашкой (кнопка показа/скрытия оверлея и т.д.), подпись — `inputs[id].displayName`.
   - Признак недоступности: вычислять так же, как на странице настроек (инпут не в списке GT из vMix или нет связи); применять тот же визуальный стиль, что и в левой колонке настроек.

### 11.3. Refactor

- Вынести общую логику «получить список инпутов в порядке inputOrder» и «определить недоступные» в хук или утилиту, чтобы не дублировать между страницей настроек и компонентом плашек.

### 11.4. Файлы для создания/изменения

| Действие | Файл |
|----------|------|
| Изменить | Компонент управления плашками vMix (найти по проекту: VMixOverlayButtons или аналог) |
| Изменить | `src/renderer/pages/MatchControlPage.jsx` (если нужно передать новые пропсы) |
| Создать/изменить | `tests/unit/renderer/VMixOverlayButtons.test.jsx` |

---

## 12. Этап 9: Интеграционное тестирование и документация

**Цель:** Прогнать сценарии из плана рефакторинга; обновить документацию.

**Ссылка на план:** этап 8 плана (тестирование и документация).

### 12.1. Интеграционные тесты

1. **Файл:** `tests/integration/vmix-settings-flow.test.js` (или .ts).
2. Сценарии (с моками IPC и vMix API где нужно):
   - Загрузка страницы настроек vMix с пустым списком инпутов → отображается пустой список, кнопка «Добавить инпут».
   - Подключение к vMix (мок успешного ответа API) → connectionState сохраняется в файл; при перезагрузке приложения состояние восстанавливается.
   - Добавление инпута, сохранение настроек, перезагрузка → инпут и порядок восстанавливаются.
   - Удаление инпута → id удаляется из inputOrder в сохранённых настройках.
   - Выбор инпута → справа загружаются поля (мок getInputFields); сопоставление поля с dataMapKey сохраняется в конфиг; при сохранении настроек записывается в файл.

### 12.2. Ручная проверка (чек-лист)

- Подключить/отключить vMix; проверить, что при следующем запуске приложения состояние восстанавливается.
- Добавить несколько инпутов, изменить порядок перетаскиванием, сохранить; после перезапуска порядок сохранён.
- Для инпута задать поля: одно из справочника, одно — произвольный текст; сохранить; на странице управления матчем убедиться, что данные уходят в vMix (при наличии vMix).
- Недоступный инпут (отключить vMix или переключить проект без этого инпута): помечен как недоступный, удаляется кнопкой «Удалить инпут»; при выборе справа поля в режиме только просмотр из кэша (если кэш был заполнен).

### 12.3. Документация

- Обновить `docs/architecture/vmix-settings-redesign-plan.md` или создать краткую заметку о переходе на динамическую модель (ссылка на план рефакторинга и на этот гайд).
- При необходимости обновить `docs/api/vmix-api-reference.md` (примеры с Input по имени/title).
- Обновить `docs/development/README.md` — добавить ссылку на инструкцию по реализации рефакторинга vMix.

---

## 13. Чек-лист по этапам (сводка)

| Этап | Тесты (Red) | Реализация (Green) | Refactor |
|------|-------------|---------------------|----------|
| 1. Подключение | connectionState в settingsManager, IPC connect/disconnect, валидация | settingsManager, main IPC, восстановление при запуске | Общая функция сохранения connectionState |
| 2. API Main | getGTInputs, getInputFields, кэш полей | vmix-client.ts, IPC | Парсинг XML, кэш |
| 3. Структура данных | inputOrder, inputs по умолчанию, удаление из inputOrder | settingsManager, validator, removeInput | Типы VMixInputConfig |
| 4. Справочник | getDataMapCatalog, фильтр по типу | dataMapCatalog.js | Расширяемая модель |
| 5. UI настроек | Пустой список, добавление, порядок, удаление, недоступные | VMixSettingsPage, модальное окно, dnd | Компоненты AddModal, InputsList |
| 6. UI полей | Раскрывающиеся блоки, сопоставление, customValue, очистить | VMixInputFieldsPanel, интеграция | VMixFieldBlock |
| 7. Отправка в vMix | useVMix по inputOrder/inputs, Input=vmixTitle, customValue/dataMapKey | useVMix.js, getValueByDataMapKey | Функция получения значения по ключу |
| 8. Плашки на матче | Список из inputOrder, недоступные | Компонент плашек, общий источник данных | Хук/утилита списка инпутов |
| 9. Интеграция и док | Интеграционные тесты, чек-лист ручной проверки | — | Документация |

---

## 14. Полезные команды

```bash
# Запуск всех тестов
npm test

# Тесты в режиме watch (при разработке)
npm run test:watch

# Покрытие кода
npm run test:coverage

# Только юнит-тесты
npm run test:unit

# Сборка приложения (проверка после этапов)
npm run build
npm run build:electron
```

---

*Документ подготовлен на основе плана рефакторинга «Работа с инпутами vMix (динамическая настройка)». При расхождении с планом приоритет у плана.*
